/* automatically generated by rust-bindgen 0.66.0 */

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[allow(unused_imports)]
    use self::super::root;
    pub const PI: f64 = 3.14159265359;
    pub const _GLIBCXX_VECTOR: u32 = 1;
    pub const _REQUIRES_FREESTANDING_H: u32 = 1;
    pub const _GLIBCXX_CXX_CONFIG_H: u32 = 1;
    pub const _GLIBCXX_RELEASE: u32 = 13;
    pub const __GLIBCXX__: u32 = 20230426;
    pub const _GLIBCXX_HAVE_ATTRIBUTE_VISIBILITY: u32 = 0;
    pub const _GLIBCXX_USE_DEPRECATED: u32 = 1;
    pub const _GLIBCXX_EXTERN_TEMPLATE: u32 = 1;
    pub const _GLIBCXX_USE_DUAL_ABI: u32 = 1;
    pub const _GLIBCXX_USE_CXX11_ABI: u32 = 1;
    pub const _GLIBCXX_INLINE_VERSION: u32 = 0;
    pub const _GLIBCXX_HAVE_IS_CONSTANT_EVALUATED: u32 = 1;
    pub const _GLIBCXX_VERBOSE_ASSERT: u32 = 1;
    pub const _GLIBCXX_USE_ALLOCATOR_NEW: u32 = 1;
    pub const __GTHREAD_HIDE_WIN32API: u32 = 1;
    pub const NOMINMAX: u32 = 1;
    pub const __USE_MINGW_ANSI_STDIO: u32 = 1;
    pub const _GLIBCXX_HAVE_DOS_BASED_FILESYSTEM: u32 = 1;
    pub const _GLIBCXX_NO_IOCTL: u32 = 1;
    pub const _GLIBCXX_LLP64: u32 = 1;
    pub const _GLIBCXX_USE_WEAK_REF: u32 = 0;
    pub const _GLIBCXX_THREAD_ATEXIT_WIN32: u32 = 1;
    pub const _GLIBCXX_USE_GET_NPROCS_WIN32: u32 = 1;
    pub const _GTHREAD_USE_MUTEX_INIT_FUNC: u32 = 1;
    pub const _GLIBCXX_USE_CRT_RAND_S: u32 = 1;
    pub const _GLIBCXX_BUFSIZ: u32 = 4096;
    pub const _GLIBCXX_CPU_DEFINES: u32 = 1;
    pub const _GLIBCXX_USE_STD_SPEC_FUNCS: u32 = 1;
    pub const _GLIBCXX_FAST_MATH: u32 = 0;
    pub const _GLIBCXX_USE_FLOAT128: u32 = 1;
    pub const _GLIBCXX_FLOAT_IS_IEEE_BINARY32: u32 = 1;
    pub const _GLIBCXX_DOUBLE_IS_IEEE_BINARY64: u32 = 1;
    pub const _GLIBCXX_HAVE_BUILTIN_HAS_UNIQ_OBJ_REP: u32 = 1;
    pub const _GLIBCXX_HAVE_BUILTIN_IS_AGGREGATE: u32 = 1;
    pub const _GLIBCXX_HAVE_BUILTIN_IS_SAME: u32 = 1;
    pub const _GLIBCXX_HAVE_BUILTIN_LAUNDER: u32 = 1;
    pub const _PSTL_VERSION: u32 = 12000;
    pub const _PSTL_VERSION_MAJOR: u32 = 12;
    pub const _PSTL_VERSION_MINOR: u32 = 0;
    pub const _PSTL_VERSION_PATCH: u32 = 0;
    pub const _PSTL_USAGE_WARNINGS: u32 = 0;
    pub const _PSTL_UDR_PRESENT: u32 = 0;
    pub const _PSTL_PRAGMA_LOCATION: &[u8; 26] = b" [Parallel STL message]: \0";
    pub const _GLIBCXX_HAVE_ACOSF: u32 = 1;
    pub const _GLIBCXX_HAVE_ACOSL: u32 = 1;
    pub const _GLIBCXX_HAVE_ASINF: u32 = 1;
    pub const _GLIBCXX_HAVE_ASINL: u32 = 1;
    pub const _GLIBCXX_HAVE_ATAN2F: u32 = 1;
    pub const _GLIBCXX_HAVE_ATAN2L: u32 = 1;
    pub const _GLIBCXX_HAVE_ATANF: u32 = 1;
    pub const _GLIBCXX_HAVE_ATANL: u32 = 1;
    pub const _GLIBCXX_HAVE_ATOMIC_LOCK_POLICY: u32 = 1;
    pub const _GLIBCXX_HAVE_AT_QUICK_EXIT: u32 = 1;
    pub const _GLIBCXX_HAVE_CEILF: u32 = 1;
    pub const _GLIBCXX_HAVE_CEILL: u32 = 1;
    pub const _GLIBCXX_HAVE_COMPLEX_H: u32 = 1;
    pub const _GLIBCXX_HAVE_COSF: u32 = 1;
    pub const _GLIBCXX_HAVE_COSHF: u32 = 1;
    pub const _GLIBCXX_HAVE_COSHL: u32 = 1;
    pub const _GLIBCXX_HAVE_COSL: u32 = 1;
    pub const _GLIBCXX_HAVE_DECL_STRNLEN: u32 = 1;
    pub const _GLIBCXX_HAVE_DIRENT_H: u32 = 1;
    pub const _GLIBCXX_HAVE_DLFCN_H: u32 = 1;
    pub const _GLIBCXX_HAVE_EXPF: u32 = 1;
    pub const _GLIBCXX_HAVE_EXPL: u32 = 1;
    pub const _GLIBCXX_HAVE_FABSF: u32 = 1;
    pub const _GLIBCXX_HAVE_FABSL: u32 = 1;
    pub const _GLIBCXX_HAVE_FCNTL_H: u32 = 1;
    pub const _GLIBCXX_HAVE_FENV_H: u32 = 1;
    pub const _GLIBCXX_HAVE_FINITE: u32 = 1;
    pub const _GLIBCXX_HAVE_FLOAT_H: u32 = 1;
    pub const _GLIBCXX_HAVE_FLOORF: u32 = 1;
    pub const _GLIBCXX_HAVE_FLOORL: u32 = 1;
    pub const _GLIBCXX_HAVE_FMODF: u32 = 1;
    pub const _GLIBCXX_HAVE_FMODL: u32 = 1;
    pub const _GLIBCXX_HAVE_FPCLASS: u32 = 1;
    pub const _GLIBCXX_HAVE_FREXPF: u32 = 1;
    pub const _GLIBCXX_HAVE_FREXPL: u32 = 1;
    pub const _GLIBCXX_HAVE_GETIPINFO: u32 = 1;
    pub const _GLIBCXX_HAVE_GETS: u32 = 1;
    pub const _GLIBCXX_HAVE_HYPOT: u32 = 1;
    pub const _GLIBCXX_HAVE_HYPOTF: u32 = 1;
    pub const _GLIBCXX_HAVE_HYPOTL: u32 = 1;
    pub const _GLIBCXX_HAVE_ICONV: u32 = 1;
    pub const _GLIBCXX_HAVE_IEEEFP_H: u32 = 1;
    pub const _GLIBCXX_HAVE_INTTYPES_H: u32 = 1;
    pub const _GLIBCXX_HAVE_ISNAN: u32 = 1;
    pub const _GLIBCXX_HAVE_ISWBLANK: u32 = 1;
    pub const _GLIBCXX_HAVE_LDEXPF: u32 = 1;
    pub const _GLIBCXX_HAVE_LDEXPL: u32 = 1;
    pub const _GLIBCXX_HAVE_LOCALE_H: u32 = 1;
    pub const _GLIBCXX_HAVE_LOG10F: u32 = 1;
    pub const _GLIBCXX_HAVE_LOG10L: u32 = 1;
    pub const _GLIBCXX_HAVE_LOGF: u32 = 1;
    pub const _GLIBCXX_HAVE_LOGL: u32 = 1;
    pub const _GLIBCXX_HAVE_MBSTATE_T: u32 = 1;
    pub const _GLIBCXX_HAVE_MEMORY_H: u32 = 1;
    pub const _GLIBCXX_HAVE_MODF: u32 = 1;
    pub const _GLIBCXX_HAVE_MODFF: u32 = 1;
    pub const _GLIBCXX_HAVE_MODFL: u32 = 1;
    pub const _GLIBCXX_HAVE_POSIX_SEMAPHORE: u32 = 1;
    pub const _GLIBCXX_HAVE_POWF: u32 = 1;
    pub const _GLIBCXX_HAVE_POWL: u32 = 1;
    pub const _GLIBCXX_HAVE_QUICK_EXIT: u32 = 1;
    pub const _GLIBCXX_HAVE_SINCOS: u32 = 1;
    pub const _GLIBCXX_HAVE_SINCOSF: u32 = 1;
    pub const _GLIBCXX_HAVE_SINCOSL: u32 = 1;
    pub const _GLIBCXX_HAVE_SINF: u32 = 1;
    pub const _GLIBCXX_HAVE_SINHF: u32 = 1;
    pub const _GLIBCXX_HAVE_SINHL: u32 = 1;
    pub const _GLIBCXX_HAVE_SINL: u32 = 1;
    pub const _GLIBCXX_HAVE_SQRTF: u32 = 1;
    pub const _GLIBCXX_HAVE_SQRTL: u32 = 1;
    pub const _GLIBCXX_HAVE_STDALIGN_H: u32 = 1;
    pub const _GLIBCXX_HAVE_STDBOOL_H: u32 = 1;
    pub const _GLIBCXX_HAVE_STDINT_H: u32 = 1;
    pub const _GLIBCXX_HAVE_STDLIB_H: u32 = 1;
    pub const _GLIBCXX_HAVE_STRINGS_H: u32 = 1;
    pub const _GLIBCXX_HAVE_STRING_H: u32 = 1;
    pub const _GLIBCXX_HAVE_STRTOF: u32 = 1;
    pub const _GLIBCXX_HAVE_STRTOLD: u32 = 1;
    pub const _GLIBCXX_HAVE_SYS_PARAM_H: u32 = 1;
    pub const _GLIBCXX_HAVE_SYS_STAT_H: u32 = 1;
    pub const _GLIBCXX_HAVE_SYS_TIME_H: u32 = 1;
    pub const _GLIBCXX_HAVE_SYS_TYPES_H: u32 = 1;
    pub const _GLIBCXX_HAVE_S_ISREG: u32 = 1;
    pub const _GLIBCXX_HAVE_TANF: u32 = 1;
    pub const _GLIBCXX_HAVE_TANHF: u32 = 1;
    pub const _GLIBCXX_HAVE_TANHL: u32 = 1;
    pub const _GLIBCXX_HAVE_TANL: u32 = 1;
    pub const _GLIBCXX_HAVE_TGMATH_H: u32 = 1;
    pub const _GLIBCXX_HAVE_TIMESPEC_GET: u32 = 1;
    pub const _GLIBCXX_HAVE_TLS: u32 = 1;
    pub const _GLIBCXX_HAVE_TRUNCATE: u32 = 1;
    pub const _GLIBCXX_HAVE_UCHAR_H: u32 = 1;
    pub const _GLIBCXX_HAVE_UNISTD_H: u32 = 1;
    pub const _GLIBCXX_HAVE_UTIME_H: u32 = 1;
    pub const _GLIBCXX_HAVE_VFWSCANF: u32 = 1;
    pub const _GLIBCXX_HAVE_VSWSCANF: u32 = 1;
    pub const _GLIBCXX_HAVE_VWSCANF: u32 = 1;
    pub const _GLIBCXX_HAVE_WCHAR_H: u32 = 1;
    pub const _GLIBCXX_HAVE_WCSTOF: u32 = 1;
    pub const _GLIBCXX_HAVE_WCTYPE_H: u32 = 1;
    pub const _GLIBCXX_HAVE_WINDOWS_H: u32 = 1;
    pub const _GLIBCXX_HAVE__ALIGNED_MALLOC: u32 = 1;
    pub const _GLIBCXX_HAVE__FINITEF: u32 = 1;
    pub const _GLIBCXX_HAVE__ISNANF: u32 = 1;
    pub const _GLIBCXX_HAVE__WFOPEN: u32 = 1;
    pub const _GLIBCXX_HAVE___CXA_THREAD_ATEXIT: u32 = 1;
    pub const _GLIBCXX_LT_OBJDIR: &[u8; 7] = b".libs/\0";
    pub const _GLIBCXX_PACKAGE_BUGREPORT: &[u8; 1] = b"\0";
    pub const _GLIBCXX_PACKAGE_NAME: &[u8; 15] = b"package-unused\0";
    pub const _GLIBCXX_PACKAGE_STRING: &[u8; 30] = b"package-unused version-unused\0";
    pub const _GLIBCXX_PACKAGE_TARNAME: &[u8; 10] = b"libstdc++\0";
    pub const _GLIBCXX_PACKAGE_URL: &[u8; 1] = b"\0";
    pub const _GLIBCXX_PACKAGE__GLIBCXX_VERSION: &[u8; 15] = b"version-unused\0";
    pub const _GLIBCXX_STDC_HEADERS: u32 = 1;
    pub const _GLIBCXX_DARWIN_USE_64_BIT_INODE: u32 = 1;
    pub const _GLIBCXX_FILE_OFFSET_BITS: u32 = 64;
    pub const _GLIBCXX11_USE_C99_COMPLEX: u32 = 1;
    pub const _GLIBCXX11_USE_C99_MATH: u32 = 1;
    pub const _GLIBCXX11_USE_C99_STDIO: u32 = 1;
    pub const _GLIBCXX11_USE_C99_STDLIB: u32 = 1;
    pub const _GLIBCXX11_USE_C99_WCHAR: u32 = 1;
    pub const _GLIBCXX98_USE_C99_COMPLEX: u32 = 1;
    pub const _GLIBCXX98_USE_C99_MATH: u32 = 1;
    pub const _GLIBCXX98_USE_C99_STDIO: u32 = 1;
    pub const _GLIBCXX98_USE_C99_STDLIB: u32 = 1;
    pub const _GLIBCXX98_USE_C99_WCHAR: u32 = 1;
    pub const _GLIBCXX_ATOMIC_BUILTINS: u32 = 1;
    pub const _GLIBCXX_FULLY_DYNAMIC_STRING: u32 = 1;
    pub const _GLIBCXX_HAS_GTHREADS: u32 = 1;
    pub const _GLIBCXX_STATIC_TZDATA: u32 = 1;
    pub const _GLIBCXX_STDIO_EOF: i32 = -1;
    pub const _GLIBCXX_STDIO_SEEK_CUR: u32 = 1;
    pub const _GLIBCXX_STDIO_SEEK_END: u32 = 2;
    pub const _GLIBCXX_USE_C11_UCHAR_CXX11: u32 = 1;
    pub const _GLIBCXX_USE_C99: u32 = 1;
    pub const _GLIBCXX_USE_C99_COMPLEX_TR1: u32 = 1;
    pub const _GLIBCXX_USE_C99_CTYPE_TR1: u32 = 1;
    pub const _GLIBCXX_USE_C99_FENV_TR1: u32 = 1;
    pub const _GLIBCXX_USE_C99_INTTYPES_TR1: u32 = 1;
    pub const _GLIBCXX_USE_C99_INTTYPES_WCHAR_T_TR1: u32 = 1;
    pub const _GLIBCXX_USE_C99_MATH_TR1: u32 = 1;
    pub const _GLIBCXX_USE_C99_STDINT_TR1: u32 = 1;
    pub const _GLIBCXX_USE_CLOCK_MONOTONIC: u32 = 1;
    pub const _GLIBCXX_USE_CLOCK_REALTIME: u32 = 1;
    pub const _GLIBCXX_USE_DECIMAL_FLOAT: u32 = 1;
    pub const _GLIBCXX_USE_GETTIMEOFDAY: u32 = 1;
    pub const _GLIBCXX_USE_LFS: u32 = 1;
    pub const _GLIBCXX_USE_LONG_LONG: u32 = 1;
    pub const _GLIBCXX_USE_NANOSLEEP: u32 = 1;
    pub const _GLIBCXX_USE_PTHREADS_NUM_PROCESSORS_NP: u32 = 1;
    pub const _GLIBCXX_USE_PTHREAD_RWLOCK_T: u32 = 1;
    pub const _GLIBCXX_USE_SCHED_YIELD: u32 = 1;
    pub const _GLIBCXX_USE_TMPNAM: u32 = 1;
    pub const _GLIBCXX_USE_UTIME: u32 = 1;
    pub const _GLIBCXX_USE_WCHAR_T: u32 = 1;
    pub const _GLIBCXX_VERBOSE: u32 = 1;
    pub const _GLIBCXX_X86_RDRAND: u32 = 1;
    pub const _GLIBCXX_X86_RDSEED: u32 = 1;
    pub const _GTHREAD_USE_MUTEX_TIMEDLOCK: u32 = 1;
    pub const _GLIBCXX_HAVE_FINITEF: u32 = 1;
    pub const _GLIBCXX_HAVE_ISNANF: u32 = 1;
    pub const _STL_ALGOBASE_H: u32 = 1;
    pub const _FUNCTEXCEPT_H: u32 = 1;
    pub const _EXCEPTION_DEFINES_H: u32 = 1;
    pub const _CPP_TYPE_TRAITS_H: u32 = 1;
    pub const _EXT_TYPE_TRAITS: u32 = 1;
    pub const _EXT_NUMERIC_TRAITS: u32 = 1;
    pub const _STL_PAIR_H: u32 = 1;
    pub const _GLIBCXX_TYPE_TRAITS: u32 = 1;
    pub const __cpp_lib_integral_constant_callable: u32 = 201304;
    pub const __cpp_lib_bool_constant: u32 = 201505;
    pub const __cpp_lib_logical_traits: u32 = 201510;
    pub const __cpp_lib_is_null_pointer: u32 = 201309;
    pub const __cpp_lib_is_final: u32 = 201402;
    pub const __cpp_lib_transformation_trait_aliases: u32 = 201304;
    pub const __cpp_lib_result_of_sfinae: u32 = 201210;
    pub const __cpp_lib_void_t: u32 = 201411;
    pub const __cpp_lib_is_swappable: u32 = 201603;
    pub const __cpp_lib_is_invocable: u32 = 201703;
    pub const __cpp_lib_type_trait_variable_templates: u32 = 201510;
    pub const __cpp_lib_has_unique_object_representations: u32 = 201606;
    pub const __cpp_lib_is_aggregate: u32 = 201703;
    pub const _MOVE_H: u32 = 1;
    pub const __cpp_lib_addressof_constexpr: u32 = 201603;
    pub const _GLIBCXX_UTILITY_H: u32 = 1;
    pub const __cpp_lib_tuple_element_t: u32 = 201402;
    pub const __cpp_lib_integer_sequence: u32 = 201304;
    pub const __cpp_lib_tuples_by_type: u32 = 201304;
    pub const _STL_ITERATOR_BASE_TYPES_H: u32 = 1;
    pub const _STL_ITERATOR_BASE_FUNCS_H: u32 = 1;
    pub const _CONCEPT_CHECK_H: u32 = 1;
    pub const _GLIBCXX_DEBUG_ASSERTIONS_H: u32 = 1;
    pub const _STL_ITERATOR_H: u32 = 1;
    pub const _PTR_TRAITS_H: u32 = 1;
    pub const __cpp_lib_array_constexpr: u32 = 201803;
    pub const __cpp_lib_make_reverse_iterator: u32 = 201402;
    pub const _GLIBCXX_DEBUG_MACRO_SWITCH_H: u32 = 1;
    pub const _GLIBCXX_PREDEFINED_OPS_H: u32 = 1;
    pub const _GLIBCXX_BIT: u32 = 1;
    pub const __cpp_lib_robust_nonmodifying_seq_ops: u32 = 201304;
    pub const _ALLOCATOR_H: u32 = 1;
    pub const _GLIBCXX_CXX_ALLOCATOR_H: u32 = 1;
    pub const _STD_NEW_ALLOCATOR_H: u32 = 1;
    pub const __EXCEPTION_H: u32 = 1;
    pub const __cpp_lib_launder: u32 = 201606;
    pub const _MEMORYFWD_H: u32 = 1;
    pub const __cpp_lib_incomplete_container_elements: u32 = 201505;
    pub const _STL_CONSTRUCT_H: u32 = 1;
    pub const _STL_UNINITIALIZED_H: u32 = 1;
    pub const _EXT_ALLOC_TRAITS_H: u32 = 1;
    pub const _ALLOC_TRAITS_H: u32 = 1;
    pub const __cpp_lib_allocator_traits_is_always_equal: u32 = 201411;
    pub const __cpp_lib_raw_memory_algorithms: u32 = 201606;
    pub const _STL_VECTOR_H: u32 = 1;
    pub const _STL_BVECTOR_H: u32 = 1;
    pub const _FUNCTIONAL_HASH_H: u32 = 1;
    pub const _HASH_BYTES_H: u32 = 1;
    pub const _GLIBCXX_REFWRAP_H: u32 = 1;
    pub const _GLIBCXX_INVOKE_H: u32 = 1;
    pub const _STL_FUNCTION_H: u32 = 1;
    pub const __cpp_lib_transparent_operators: u32 = 201510;
    pub const _BACKWARD_BINDERS_H: u32 = 1;
    pub const _GLIBCXX_RANGE_ACCESS_H: u32 = 1;
    pub const __cpp_lib_nonmember_container_access: u32 = 201411;
    pub const _VECTOR_TCC: u32 = 1;
    pub const _GLIBCXX_MEMORY_RESOURCE_H: u32 = 1;
    pub const _GLIBCXX_CSTDDEF: u32 = 1;
    pub const NULL: u32 = 0;
    pub const __cpp_lib_byte: u32 = 201603;
    pub const _USES_ALLOCATOR_H: u32 = 1;
    pub const _USES_ALLOCATOR_ARGS: u32 = 1;
    pub const _GLIBCXX_TUPLE: u32 = 1;
    pub const __cpp_lib_apply: u32 = 201603;
    pub const __cpp_lib_make_from_tuple: u32 = 201606;
    pub const __MINGW64_VERSION_MAJOR: u32 = 11;
    pub const __MINGW64_VERSION_MINOR: u32 = 0;
    pub const __MINGW64_VERSION_BUGFIX: u32 = 0;
    pub const __MINGW64_VERSION_RC: u32 = 0;
    pub const __MINGW64_VERSION_STATE: &[u8; 6] = b"alpha\0";
    pub const __MINGW32_MAJOR_VERSION: u32 = 3;
    pub const __MINGW32_MINOR_VERSION: u32 = 11;
    pub const _M_AMD64: u32 = 100;
    pub const _M_X64: u32 = 100;
    pub const __: u32 = 1;
    pub const __MINGW_USE_UNDERSCORE_PREFIX: u32 = 0;
    pub const __MINGW_HAVE_ANSI_C99_PRINTF: u32 = 1;
    pub const __MINGW_HAVE_WIDE_C99_PRINTF: u32 = 1;
    pub const __MINGW_HAVE_ANSI_C99_SCANF: u32 = 1;
    pub const __MINGW_HAVE_WIDE_C99_SCANF: u32 = 1;
    pub const __MINGW_SEC_WARN_STR : & [u8 ; 92] = b"This function or variable may be unsafe, use _CRT_SECURE_NO_WARNINGS to disable deprecation\0" ;
    pub const __MINGW_MSVC2005_DEPREC_STR : & [u8 ; 117] = b"This POSIX function is deprecated beginning in Visual C++ 2005, use _CRT_NONSTDC_NO_DEPRECATE to disable deprecation\0" ;
    pub const __MINGW_FORTIFY_LEVEL: u32 = 0;
    pub const __MINGW_FORTIFY_VA_ARG: u32 = 0;
    pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: u32 = 1;
    pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: u32 = 0;
    pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: u32 = 0;
    pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: u32 = 0;
    pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: u32 = 0;
    pub const __USE_CRTIMP: u32 = 1;
    pub const USE___UUIDOF: u32 = 0;
    pub const __CRT__NO_INLINE: u32 = 1;
    pub const __MSVCRT_VERSION__: u32 = 3584;
    pub const _WIN32_WINNT: u32 = 1537;
    pub const MINGW_HAS_SECURE_API: u32 = 1;
    pub const __STDC_SECURE_LIB__: u32 = 200411;
    pub const __GOT_SECURE_LIB__: u32 = 200411;
    pub const MINGW_HAS_DDK_H: u32 = 1;
    pub const _CRT_PACKING: u32 = 8;
    pub const _SECURECRT_FILL_BUFFER_PATTERN: u32 = 253;
    pub const _ARGMAX: u32 = 100;
    pub const _DOMAIN: u32 = 1;
    pub const _SING: u32 = 2;
    pub const _OVERFLOW: u32 = 3;
    pub const _UNDERFLOW: u32 = 4;
    pub const _TLOSS: u32 = 5;
    pub const _PLOSS: u32 = 6;
    pub const DOMAIN: u32 = 1;
    pub const SING: u32 = 2;
    pub const OVERFLOW: u32 = 3;
    pub const UNDERFLOW: u32 = 4;
    pub const TLOSS: u32 = 5;
    pub const PLOSS: u32 = 6;
    pub const M_E: f64 = 2.718281828459045;
    pub const M_LOG2E: f64 = 1.4426950408889634;
    pub const M_LOG10E: f64 = 0.4342944819032518;
    pub const M_LN2: f64 = 0.6931471805599453;
    pub const M_LN10: f64 = 2.302585092994046;
    pub const M_PI: f64 = 3.141592653589793;
    pub const M_PI_2: f64 = 1.5707963267948966;
    pub const M_PI_4: f64 = 0.7853981633974483;
    pub const M_1_PI: f64 = 0.3183098861837907;
    pub const M_2_PI: f64 = 0.6366197723675814;
    pub const M_2_SQRTPI: f64 = 1.1283791670955126;
    pub const M_SQRT2: f64 = 1.4142135623730951;
    pub const M_SQRT1_2: f64 = 0.7071067811865476;
    pub const __MINGW_FPCLASS_DEFINED: u32 = 1;
    pub const _FPCLASS_SNAN: u32 = 1;
    pub const _FPCLASS_QNAN: u32 = 2;
    pub const _FPCLASS_NINF: u32 = 4;
    pub const _FPCLASS_NN: u32 = 8;
    pub const _FPCLASS_ND: u32 = 16;
    pub const _FPCLASS_NZ: u32 = 32;
    pub const _FPCLASS_PZ: u32 = 64;
    pub const _FPCLASS_PD: u32 = 128;
    pub const _FPCLASS_PN: u32 = 256;
    pub const _FPCLASS_PINF: u32 = 512;
    pub const EDOM: u32 = 33;
    pub const ERANGE: u32 = 34;
    pub const FP_SNAN: u32 = 1;
    pub const FP_QNAN: u32 = 2;
    pub const FP_NINF: u32 = 4;
    pub const FP_PINF: u32 = 512;
    pub const FP_NDENORM: u32 = 16;
    pub const FP_PDENORM: u32 = 128;
    pub const FP_NZERO: u32 = 32;
    pub const FP_PZERO: u32 = 64;
    pub const FP_NNORM: u32 = 8;
    pub const FP_PNORM: u32 = 256;
    pub const FP_NAN: u32 = 256;
    pub const FP_NORMAL: u32 = 1024;
    pub const FP_INFINITE: u32 = 1280;
    pub const FP_ZERO: u32 = 16384;
    pub const FP_SUBNORMAL: u32 = 17408;
    pub const PATH_MAX: u32 = 260;
    pub const CHAR_BIT: u32 = 8;
    pub const SCHAR_MIN: i32 = -128;
    pub const SCHAR_MAX: u32 = 127;
    pub const UCHAR_MAX: u32 = 255;
    pub const CHAR_MIN: i32 = -128;
    pub const CHAR_MAX: u32 = 127;
    pub const MB_LEN_MAX: u32 = 5;
    pub const SHRT_MIN: i32 = -32768;
    pub const SHRT_MAX: u32 = 32767;
    pub const USHRT_MAX: u32 = 65535;
    pub const INT_MIN: i32 = -2147483648;
    pub const INT_MAX: u32 = 2147483647;
    pub const UINT_MAX: u32 = 4294967295;
    pub const LONG_MIN: i32 = -2147483648;
    pub const LONG_MAX: u32 = 2147483647;
    pub const ULONG_MAX: u32 = 4294967295;
    pub const LLONG_MAX: u64 = 9223372036854775807;
    pub const LLONG_MIN: i64 = -9223372036854775808;
    pub const ULLONG_MAX: i32 = -1;
    pub const _I8_MIN: i32 = -128;
    pub const _I8_MAX: u32 = 127;
    pub const _UI8_MAX: u32 = 255;
    pub const _I16_MIN: i32 = -32768;
    pub const _I16_MAX: u32 = 32767;
    pub const _UI16_MAX: u32 = 65535;
    pub const _I32_MIN: i32 = -2147483648;
    pub const _I32_MAX: u32 = 2147483647;
    pub const _UI32_MAX: u32 = 4294967295;
    pub const LONG_LONG_MAX: u64 = 9223372036854775807;
    pub const LONG_LONG_MIN: i64 = -9223372036854775808;
    pub const ULONG_LONG_MAX: i32 = -1;
    pub const _I64_MIN: i64 = -9223372036854775808;
    pub const _I64_MAX: u64 = 9223372036854775807;
    pub const _UI64_MAX: i32 = -1;
    pub const SIZE_MAX: i32 = -1;
    pub const SSIZE_MAX: u64 = 9223372036854775807;
    pub const __USE_MINGW_STRTOX: u32 = 1;
    pub const EXIT_SUCCESS: u32 = 0;
    pub const EXIT_FAILURE: u32 = 1;
    pub const RAND_MAX: u32 = 32767;
    pub const _MAX_PATH: u32 = 260;
    pub const _MAX_DRIVE: u32 = 3;
    pub const _MAX_DIR: u32 = 256;
    pub const _MAX_FNAME: u32 = 256;
    pub const _MAX_EXT: u32 = 256;
    pub const _OUT_TO_DEFAULT: u32 = 0;
    pub const _OUT_TO_STDERR: u32 = 1;
    pub const _OUT_TO_MSGBOX: u32 = 2;
    pub const _REPORT_ERRMODE: u32 = 3;
    pub const _WRITE_ABORT_MSG: u32 = 1;
    pub const _CALL_REPORTFAULT: u32 = 2;
    pub const _MAX_ENV: u32 = 32767;
    pub const _CVTBUFSIZE: u32 = 349;
    pub const _HEAP_MAXREQ: i32 = -32;
    pub const _HEAPEMPTY: i32 = -1;
    pub const _HEAPOK: i32 = -2;
    pub const _HEAPBADBEGIN: i32 = -3;
    pub const _HEAPBADNODE: i32 = -4;
    pub const _HEAPEND: i32 = -5;
    pub const _HEAPBADPTR: i32 = -6;
    pub const _FREEENTRY: u32 = 0;
    pub const _USEDENTRY: u32 = 1;
    pub const _MAX_WAIT_MALLOC_CRT: u32 = 60000;
    pub const _ALLOCA_S_THRESHOLD: u32 = 1024;
    pub const _ALLOCA_S_STACK_MARKER: u32 = 52428;
    pub const _ALLOCA_S_HEAP_MARKER: u32 = 56797;
    pub const _ALLOCA_S_MARKER_SIZE: u32 = 16;
    pub const _GLIBCXX_CMATH: u32 = 1;
    pub const __cpp_lib_hypot: u32 = 201603;
    pub const _GLIBCXX_BITS_SPECFUN_H: u32 = 1;
    pub const __STDCPP_MATH_SPEC_FUNCS__: u32 = 201003;
    pub const __cpp_lib_math_special_functions: u32 = 201603;
    pub const _GLIBCXX_NUMERIC_LIMITS: u32 = 1;
    pub const _GLIBCXX_TR1_GAMMA_TCC: u32 = 1;
    pub const _GLIBCXX_TR1_SPECIAL_FUNCTION_UTIL_H: u32 = 1;
    pub const _GLIBCXX_TR1_BESSEL_FUNCTION_TCC: u32 = 1;
    pub const _GLIBCXX_TR1_BETA_FUNCTION_TCC: u32 = 1;
    pub const _GLIBCXX_TR1_ELL_INTEGRAL_TCC: u32 = 1;
    pub const _GLIBCXX_TR1_EXP_INTEGRAL_TCC: u32 = 1;
    pub const _GLIBCXX_TR1_HYPERGEOMETRIC_TCC: u32 = 1;
    pub const _GLIBCXX_TR1_LEGENDRE_FUNCTION_TCC: u32 = 1;
    pub const _GLIBCXX_TR1_MODIFIED_BESSEL_FUNC_TCC: u32 = 1;
    pub const _GLIBCXX_TR1_POLY_HERMITE_TCC: u32 = 1;
    pub const _GLIBCXX_TR1_POLY_LAGUERRE_TCC: u32 = 1;
    pub const _GLIBCXX_TR1_RIEMANN_ZETA_TCC: u32 = 1;
    pub const _GLIBCXX_STDLIB_H: u32 = 1;
    pub const _GLIBCXX_CSTDLIB: u32 = 1;
    pub const e: f64 = 2.718281828459;
    pub const _UPPER: u32 = 1;
    pub const _LOWER: u32 = 2;
    pub const _DIGIT: u32 = 4;
    pub const _SPACE: u32 = 8;
    pub const _PUNCT: u32 = 16;
    pub const _CONTROL: u32 = 32;
    pub const _BLANK: u32 = 64;
    pub const _HEX: u32 = 128;
    pub const _LEADBYTE: u32 = 32768;
    pub const _ALPHA: u32 = 259;
    pub const _GLIBCXX_CCTYPE: u32 = 1;
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub type nullptr_t = u64;
        extern "C" {
            #[link_name = "\u{1}_ZSt21__throw_bad_exceptionv"]
            pub fn __throw_bad_exception() -> !;
        }
        extern "C" {
            #[link_name = "\u{1}_ZSt17__throw_bad_allocv"]
            pub fn __throw_bad_alloc() -> !;
        }
        extern "C" {
            #[link_name = "\u{1}_ZSt28__throw_bad_array_new_lengthv"]
            pub fn __throw_bad_array_new_length() -> !;
        }
        extern "C" {
            #[link_name = "\u{1}_ZSt16__throw_bad_castv"]
            pub fn __throw_bad_cast() -> !;
        }
        extern "C" {
            #[link_name = "\u{1}_ZSt18__throw_bad_typeidv"]
            pub fn __throw_bad_typeid() -> !;
        }
        extern "C" {
            #[link_name = "\u{1}_ZSt19__throw_logic_errorPKc"]
            pub fn __throw_logic_error(arg1: *const ::std::os::raw::c_char) -> !;
        }
        extern "C" {
            #[link_name = "\u{1}_ZSt20__throw_domain_errorPKc"]
            pub fn __throw_domain_error(arg1: *const ::std::os::raw::c_char) -> !;
        }
        extern "C" {
            #[link_name = "\u{1}_ZSt24__throw_invalid_argumentPKc"]
            pub fn __throw_invalid_argument(arg1: *const ::std::os::raw::c_char) -> !;
        }
        extern "C" {
            #[link_name = "\u{1}_ZSt20__throw_length_errorPKc"]
            pub fn __throw_length_error(arg1: *const ::std::os::raw::c_char) -> !;
        }
        extern "C" {
            #[link_name = "\u{1}_ZSt20__throw_out_of_rangePKc"]
            pub fn __throw_out_of_range(arg1: *const ::std::os::raw::c_char) -> !;
        }
        extern "C" {
            #[link_name = "\u{1}_ZSt24__throw_out_of_range_fmtPKcz"]
            pub fn __throw_out_of_range_fmt(arg1: *const ::std::os::raw::c_char, ...) -> !;
        }
        extern "C" {
            #[link_name = "\u{1}_ZSt21__throw_runtime_errorPKc"]
            pub fn __throw_runtime_error(arg1: *const ::std::os::raw::c_char) -> !;
        }
        extern "C" {
            #[link_name = "\u{1}_ZSt19__throw_range_errorPKc"]
            pub fn __throw_range_error(arg1: *const ::std::os::raw::c_char) -> !;
        }
        extern "C" {
            #[link_name = "\u{1}_ZSt22__throw_overflow_errorPKc"]
            pub fn __throw_overflow_error(arg1: *const ::std::os::raw::c_char) -> !;
        }
        extern "C" {
            #[link_name = "\u{1}_ZSt23__throw_underflow_errorPKc"]
            pub fn __throw_underflow_error(arg1: *const ::std::os::raw::c_char) -> !;
        }
        extern "C" {
            #[link_name = "\u{1}_ZSt19__throw_ios_failurePKc"]
            pub fn __throw_ios_failure(arg1: *const ::std::os::raw::c_char) -> !;
        }
        extern "C" {
            #[link_name = "\u{1}_ZSt19__throw_ios_failurePKci"]
            pub fn __throw_ios_failure1(
                arg1: *const ::std::os::raw::c_char,
                arg2: ::std::os::raw::c_int,
            ) -> !;
        }
        extern "C" {
            #[link_name = "\u{1}_ZSt20__throw_system_errori"]
            pub fn __throw_system_error(arg1: ::std::os::raw::c_int) -> !;
        }
        extern "C" {
            #[link_name = "\u{1}_ZSt20__throw_future_errori"]
            pub fn __throw_future_error(arg1: ::std::os::raw::c_int) -> !;
        }
        extern "C" {
            #[link_name = "\u{1}_ZSt25__throw_bad_function_callv"]
            pub fn __throw_bad_function_call() -> !;
        }
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Debug, Copy, Clone)]
        pub struct __true_type {
            pub _bindgen_opaque_blob: u8,
        }
        #[test]
        fn bindgen_test_layout___true_type() {
            assert_eq!(
                ::std::mem::size_of::<__true_type>(),
                1usize,
                concat!("Size of: ", stringify!(__true_type))
            );
            assert_eq!(
                ::std::mem::align_of::<__true_type>(),
                1usize,
                concat!("Alignment of ", stringify!(__true_type))
            );
        }
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Debug, Copy, Clone)]
        pub struct __false_type {
            pub _bindgen_opaque_blob: u8,
        }
        #[test]
        fn bindgen_test_layout___false_type() {
            assert_eq!(
                ::std::mem::size_of::<__false_type>(),
                1usize,
                concat!("Size of: ", stringify!(__false_type))
            );
            assert_eq!(
                ::std::mem::align_of::<__false_type>(),
                1usize,
                concat!("Alignment of ", stringify!(__false_type))
            );
        }
        pub type __truth_type___type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __traitor {
            pub _address: u8,
        }
        pub const __traitor___value: root::std::__traitor__bindgen_ty_1 = 0;
        pub type __traitor__bindgen_ty_1 = i32;
        pub type __traitor___type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __are_same {
            pub _address: u8,
        }
        pub const __are_same___value: root::std::__are_same__bindgen_ty_1 = 0;
        pub type __are_same__bindgen_ty_1 = i32;
        pub type __are_same___type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __is_void {
            pub _address: u8,
        }
        pub const __is_void___value: root::std::__is_void__bindgen_ty_1 = 0;
        pub type __is_void__bindgen_ty_1 = i32;
        pub type __is_void___type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __is_integer {
            pub _address: u8,
        }
        pub const __is_integer___value: root::std::__is_integer__bindgen_ty_1 = 0;
        pub type __is_integer__bindgen_ty_1 = i32;
        pub type __is_integer___type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __is_floating {
            pub _address: u8,
        }
        pub const __is_floating___value: root::std::__is_floating__bindgen_ty_1 = 0;
        pub type __is_floating__bindgen_ty_1 = i32;
        pub type __is_floating___type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __is_pointer {
            pub _address: u8,
        }
        pub const __is_pointer___value: root::std::__is_pointer__bindgen_ty_1 = 0;
        pub type __is_pointer__bindgen_ty_1 = i32;
        pub type __is_pointer___type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __is_arithmetic {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __is_scalar {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __is_char {
            pub _address: u8,
        }
        pub const __is_char___value: root::std::__is_char__bindgen_ty_1 = 0;
        pub type __is_char__bindgen_ty_1 = i32;
        pub type __is_char___type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __is_byte {
            pub _address: u8,
        }
        pub const __is_byte___value: root::std::__is_byte__bindgen_ty_1 = 0;
        pub type __is_byte__bindgen_ty_1 = i32;
        pub type __is_byte___type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __is_nonvolatile_trivially_copyable {
            pub _address: u8,
        }
        pub const __is_nonvolatile_trivially_copyable___value:
            root::std::__is_nonvolatile_trivially_copyable__bindgen_ty_1 = 0;
        pub type __is_nonvolatile_trivially_copyable__bindgen_ty_1 = i32;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __memcpyable {
            pub _address: u8,
        }
        pub const __memcpyable___value: root::std::__memcpyable__bindgen_ty_1 = 0;
        pub type __memcpyable__bindgen_ty_1 = i32;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __memcmpable {
            pub _address: u8,
        }
        pub const __memcmpable___value: root::std::__memcmpable__bindgen_ty_1 = 0;
        pub type __memcmpable__bindgen_ty_1 = i32;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __is_move_iterator {
            pub _address: u8,
        }
        pub const __is_move_iterator___value: root::std::__is_move_iterator__bindgen_ty_1 = 0;
        pub type __is_move_iterator__bindgen_ty_1 = i32;
        pub type __is_move_iterator___type = u8;
        pub type integral_constant_value_type = u8;
        pub type integral_constant_type = u8;
        pub type true_type = u8;
        pub type false_type = u8;
        pub type __bool_constant = u8;
        pub type bool_constant = u8;
        pub type __enable_if_t = u8;
        pub type __conditional_type = u8;
        pub type __conditional_t = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __type_identity {
            pub _address: u8,
        }
        pub type __type_identity_type = u8;
        pub type __type_identity_t = u8;
        pub mod __detail {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub type __first_t = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct __disjunction_impl {
                pub _address: u8,
            }
            pub type __disjunction_impl_type = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct __conjunction_impl {
                pub _address: u8,
            }
            pub type __conjunction_impl_type = u8;
            pub mod __variant {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
                #[repr(C)]
                #[derive(Debug, Copy, Clone)]
                pub struct _Never_valueless_alt {
                    pub _address: u8,
                }
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct __floating_point_constant {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct __numeric_constants {
                pub _address: u8,
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __or_ {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __and_ {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __not_ {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct conjunction {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct disjunction {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct negation {
            pub _address: u8,
        }
        pub type __remove_cv_t = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_void {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __is_integral_helper {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_integral {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __is_floating_point_helper {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_floating_point {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_array {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __is_pointer_helper {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_pointer {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_lvalue_reference {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_rvalue_reference {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __is_member_object_pointer_helper {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_member_object_pointer {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __is_member_function_pointer_helper {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_member_function_pointer {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_enum {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_union {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_class {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_function {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_null_pointer {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __is_nullptr_t {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_reference {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_arithmetic {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_fundamental {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_object {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_scalar {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_compound {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __is_member_pointer_helper {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_member_pointer {
            pub _address: u8,
        }
        pub type __is_one_of = u8;
        pub type __is_signed_integer = u8;
        pub type __is_unsigned_integer = u8;
        pub type __is_standard_integer = u8;
        pub type __void_t = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_const {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_volatile {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_trivial {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_trivially_copyable {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_standard_layout {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_pod {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_literal_type {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_empty {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_polymorphic {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_final {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_abstract {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_signed {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_unsigned {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __is_array_known_bounds {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __is_array_unknown_bounds {
            pub _address: u8,
        }
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Debug, Copy, Clone)]
        pub struct __do_is_destructible_impl {
            pub _bindgen_opaque_blob: u8,
        }
        #[test]
        fn bindgen_test_layout___do_is_destructible_impl() {
            assert_eq!(
                ::std::mem::size_of::<__do_is_destructible_impl>(),
                1usize,
                concat!("Size of: ", stringify!(__do_is_destructible_impl))
            );
            assert_eq!(
                ::std::mem::align_of::<__do_is_destructible_impl>(),
                1usize,
                concat!("Alignment of ", stringify!(__do_is_destructible_impl))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __is_destructible_impl {
            pub _address: u8,
        }
        pub type __is_destructible_impl_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_destructible {
            pub _address: u8,
        }
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Debug, Copy, Clone)]
        pub struct __do_is_nt_destructible_impl {
            pub _bindgen_opaque_blob: u8,
        }
        #[test]
        fn bindgen_test_layout___do_is_nt_destructible_impl() {
            assert_eq!(
                ::std::mem::size_of::<__do_is_nt_destructible_impl>(),
                1usize,
                concat!("Size of: ", stringify!(__do_is_nt_destructible_impl))
            );
            assert_eq!(
                ::std::mem::align_of::<__do_is_nt_destructible_impl>(),
                1usize,
                concat!("Alignment of ", stringify!(__do_is_nt_destructible_impl))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __is_nt_destructible_impl {
            pub _address: u8,
        }
        pub type __is_nt_destructible_impl_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_nothrow_destructible {
            pub _address: u8,
        }
        pub type __is_constructible_impl = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_constructible {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_default_constructible {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __add_lvalue_reference_helper {
            pub _address: u8,
        }
        pub type __add_lvalue_reference_helper_type = u8;
        pub type __add_lval_ref_t = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_copy_constructible {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __add_rvalue_reference_helper {
            pub _address: u8,
        }
        pub type __add_rvalue_reference_helper_type = u8;
        pub type __add_rval_ref_t = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_move_constructible {
            pub _address: u8,
        }
        pub type __is_nothrow_constructible_impl = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_nothrow_constructible {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_nothrow_default_constructible {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_nothrow_copy_constructible {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_nothrow_move_constructible {
            pub _address: u8,
        }
        pub type __is_assignable_impl = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_assignable {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_copy_assignable {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_move_assignable {
            pub _address: u8,
        }
        pub type __is_nothrow_assignable_impl = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_nothrow_assignable {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_nothrow_copy_assignable {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_nothrow_move_assignable {
            pub _address: u8,
        }
        pub type __is_trivially_constructible_impl = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_trivially_constructible {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_trivially_default_constructible {
            pub _address: u8,
        }
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Debug, Copy, Clone)]
        pub struct __do_is_implicitly_default_constructible_impl {
            pub _bindgen_opaque_blob: u8,
        }
        #[test]
        fn bindgen_test_layout___do_is_implicitly_default_constructible_impl() {
            assert_eq!(
                ::std::mem::size_of::<__do_is_implicitly_default_constructible_impl>(),
                1usize,
                concat!(
                    "Size of: ",
                    stringify!(__do_is_implicitly_default_constructible_impl)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<__do_is_implicitly_default_constructible_impl>(),
                1usize,
                concat!(
                    "Alignment of ",
                    stringify!(__do_is_implicitly_default_constructible_impl)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt45__do_is_implicitly_default_constructible_impl6__testEz"]
            pub fn __do_is_implicitly_default_constructible_impl___test() -> root::std::false_type;
        }
        impl __do_is_implicitly_default_constructible_impl {
            #[inline]
            pub unsafe fn __test() -> root::std::false_type {
                __do_is_implicitly_default_constructible_impl___test()
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __is_implicitly_default_constructible_impl {
            pub _address: u8,
        }
        pub type __is_implicitly_default_constructible_impl_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __is_implicitly_default_constructible_safe {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __is_implicitly_default_constructible {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_trivially_copy_constructible {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_trivially_move_constructible {
            pub _address: u8,
        }
        pub type __is_trivially_assignable_impl = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_trivially_assignable {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_trivially_copy_assignable {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_trivially_move_assignable {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_trivially_destructible {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct has_virtual_destructor {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct alignment_of {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct rank {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_same {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_base_of {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_convertible {
            pub _address: u8,
        }
        pub type __is_array_convertible = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct remove_const {
            pub _address: u8,
        }
        pub type remove_const_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct remove_volatile {
            pub _address: u8,
        }
        pub type remove_volatile_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct remove_cv {
            pub _address: u8,
        }
        pub type remove_cv_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct add_const {
            pub _address: u8,
        }
        pub type add_const_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct add_volatile {
            pub _address: u8,
        }
        pub type add_volatile_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct add_cv {
            pub _address: u8,
        }
        pub type add_cv_type = u8;
        pub type remove_const_t = u8;
        pub type remove_volatile_t = u8;
        pub type remove_cv_t = u8;
        pub type add_const_t = u8;
        pub type add_volatile_t = u8;
        pub type add_cv_t = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct remove_reference {
            pub _address: u8,
        }
        pub type remove_reference_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct add_lvalue_reference {
            pub _address: u8,
        }
        pub type add_lvalue_reference_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct add_rvalue_reference {
            pub _address: u8,
        }
        pub type add_rvalue_reference_type = u8;
        pub type remove_reference_t = u8;
        pub type add_lvalue_reference_t = u8;
        pub type add_rvalue_reference_t = u8;
        pub type __match_cv_qualifiers___match = u8;
        pub type __match_cv_qualifiers___type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __make_unsigned {
            pub _address: u8,
        }
        pub type __make_unsigned___type = u8;
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Debug, Copy, Clone)]
        pub struct __make_unsigned_selector_base {
            pub _bindgen_opaque_blob: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __make_unsigned_selector_base__List {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout___make_unsigned_selector_base() {
            assert_eq!(
                ::std::mem::size_of::<__make_unsigned_selector_base>(),
                1usize,
                concat!("Size of: ", stringify!(__make_unsigned_selector_base))
            );
            assert_eq!(
                ::std::mem::align_of::<__make_unsigned_selector_base>(),
                1usize,
                concat!("Alignment of ", stringify!(__make_unsigned_selector_base))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct make_unsigned {
            pub _address: u8,
        }
        pub type make_unsigned_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __make_signed {
            pub _address: u8,
        }
        pub type __make_signed___type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct make_signed {
            pub _address: u8,
        }
        pub type make_signed_type = u8;
        pub type make_signed_t = u8;
        pub type make_unsigned_t = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct remove_extent {
            pub _address: u8,
        }
        pub type remove_extent_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct remove_all_extents {
            pub _address: u8,
        }
        pub type remove_all_extents_type = u8;
        pub type remove_extent_t = u8;
        pub type remove_all_extents_t = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __remove_pointer_helper {
            pub _address: u8,
        }
        pub type __remove_pointer_helper_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct remove_pointer {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __add_pointer_helper {
            pub _address: u8,
        }
        pub type __add_pointer_helper_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct add_pointer {
            pub _address: u8,
        }
        pub type remove_pointer_t = u8;
        pub type add_pointer_t = u8;
        #[repr(C)]
        #[repr(align(8))]
        #[derive(Copy, Clone)]
        pub union __aligned_storage_msa___type {
            pub _bindgen_opaque_blob: u64,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __aligned_storage_msa___type__bindgen_ty_1 {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout___aligned_storage_msa___type() {
            assert_eq!(
                ::std::mem::size_of::<__aligned_storage_msa___type>(),
                8usize,
                concat!("Size of: ", stringify!(__aligned_storage_msa___type))
            );
            assert_eq!(
                ::std::mem::align_of::<__aligned_storage_msa___type>(),
                8usize,
                concat!("Alignment of ", stringify!(__aligned_storage_msa___type))
            );
        }
        #[repr(C)]
        #[repr(align(8))]
        #[derive(Copy, Clone)]
        pub union aligned_storage_type {
            pub _bindgen_opaque_blob: u64,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct aligned_storage_type__bindgen_ty_1 {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_aligned_storage_type() {
            assert_eq!(
                ::std::mem::size_of::<aligned_storage_type>(),
                8usize,
                concat!("Size of: ", stringify!(aligned_storage_type))
            );
            assert_eq!(
                ::std::mem::align_of::<aligned_storage_type>(),
                8usize,
                concat!("Alignment of ", stringify!(aligned_storage_type))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __strictest_alignment {
            pub _address: u8,
        }
        pub type aligned_union___strictest = u8;
        pub type aligned_union_type = u8;
        extern "C" {
            pub static alignment_value: usize;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __decay_selector {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct decay {
            pub _address: u8,
        }
        pub type decay_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __strip_reference_wrapper {
            pub _address: u8,
        }
        pub type __strip_reference_wrapper___type = u8;
        pub type __decay_t = u8;
        pub type __decay_and_strip = u8;
        pub type _Require = u8;
        pub type __remove_cvref_t = u8;
        pub type conditional_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct common_type {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __success_type {
            pub _address: u8,
        }
        pub type __success_type_type = u8;
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Debug, Copy, Clone)]
        pub struct __failure_type {
            pub _bindgen_opaque_blob: u8,
        }
        #[test]
        fn bindgen_test_layout___failure_type() {
            assert_eq!(
                ::std::mem::size_of::<__failure_type>(),
                1usize,
                concat!("Size of: ", stringify!(__failure_type))
            );
            assert_eq!(
                ::std::mem::align_of::<__failure_type>(),
                1usize,
                concat!("Alignment of ", stringify!(__failure_type))
            );
        }
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Debug, Copy, Clone)]
        pub struct __do_common_type_impl {
            pub _bindgen_opaque_blob: u8,
        }
        pub type __do_common_type_impl___cond_t = u8;
        #[test]
        fn bindgen_test_layout___do_common_type_impl() {
            assert_eq!(
                ::std::mem::size_of::<__do_common_type_impl>(),
                1usize,
                concat!("Size of: ", stringify!(__do_common_type_impl))
            );
            assert_eq!(
                ::std::mem::align_of::<__do_common_type_impl>(),
                1usize,
                concat!("Alignment of ", stringify!(__do_common_type_impl))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __common_type_impl {
            pub _address: u8,
        }
        pub type __common_type_impl_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __common_type_pack {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __common_type_fold {
            pub _address: u8,
        }
        pub type __underlying_type_impl_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct underlying_type {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __declval_protector {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct result_of {
            pub _address: u8,
        }
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Debug, Copy, Clone)]
        pub struct __invoke_memfun_ref {
            pub _bindgen_opaque_blob: u8,
        }
        #[test]
        fn bindgen_test_layout___invoke_memfun_ref() {
            assert_eq!(
                ::std::mem::size_of::<__invoke_memfun_ref>(),
                1usize,
                concat!("Size of: ", stringify!(__invoke_memfun_ref))
            );
            assert_eq!(
                ::std::mem::align_of::<__invoke_memfun_ref>(),
                1usize,
                concat!("Alignment of ", stringify!(__invoke_memfun_ref))
            );
        }
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Debug, Copy, Clone)]
        pub struct __invoke_memfun_deref {
            pub _bindgen_opaque_blob: u8,
        }
        #[test]
        fn bindgen_test_layout___invoke_memfun_deref() {
            assert_eq!(
                ::std::mem::size_of::<__invoke_memfun_deref>(),
                1usize,
                concat!("Size of: ", stringify!(__invoke_memfun_deref))
            );
            assert_eq!(
                ::std::mem::align_of::<__invoke_memfun_deref>(),
                1usize,
                concat!("Alignment of ", stringify!(__invoke_memfun_deref))
            );
        }
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Debug, Copy, Clone)]
        pub struct __invoke_memobj_ref {
            pub _bindgen_opaque_blob: u8,
        }
        #[test]
        fn bindgen_test_layout___invoke_memobj_ref() {
            assert_eq!(
                ::std::mem::size_of::<__invoke_memobj_ref>(),
                1usize,
                concat!("Size of: ", stringify!(__invoke_memobj_ref))
            );
            assert_eq!(
                ::std::mem::align_of::<__invoke_memobj_ref>(),
                1usize,
                concat!("Alignment of ", stringify!(__invoke_memobj_ref))
            );
        }
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Debug, Copy, Clone)]
        pub struct __invoke_memobj_deref {
            pub _bindgen_opaque_blob: u8,
        }
        #[test]
        fn bindgen_test_layout___invoke_memobj_deref() {
            assert_eq!(
                ::std::mem::size_of::<__invoke_memobj_deref>(),
                1usize,
                concat!("Size of: ", stringify!(__invoke_memobj_deref))
            );
            assert_eq!(
                ::std::mem::align_of::<__invoke_memobj_deref>(),
                1usize,
                concat!("Alignment of ", stringify!(__invoke_memobj_deref))
            );
        }
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Debug, Copy, Clone)]
        pub struct __invoke_other {
            pub _bindgen_opaque_blob: u8,
        }
        #[test]
        fn bindgen_test_layout___invoke_other() {
            assert_eq!(
                ::std::mem::size_of::<__invoke_other>(),
                1usize,
                concat!("Size of: ", stringify!(__invoke_other))
            );
            assert_eq!(
                ::std::mem::align_of::<__invoke_other>(),
                1usize,
                concat!("Alignment of ", stringify!(__invoke_other))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __result_of_success {
            pub _address: u8,
        }
        pub type __result_of_success___invoke_type = u8;
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Debug, Copy, Clone)]
        pub struct __result_of_memfun_ref_impl {
            pub _bindgen_opaque_blob: u8,
        }
        #[test]
        fn bindgen_test_layout___result_of_memfun_ref_impl() {
            assert_eq!(
                ::std::mem::size_of::<__result_of_memfun_ref_impl>(),
                1usize,
                concat!("Size of: ", stringify!(__result_of_memfun_ref_impl))
            );
            assert_eq!(
                ::std::mem::align_of::<__result_of_memfun_ref_impl>(),
                1usize,
                concat!("Alignment of ", stringify!(__result_of_memfun_ref_impl))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __result_of_memfun_ref {
            pub _address: u8,
        }
        pub type __result_of_memfun_ref_type = u8;
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Debug, Copy, Clone)]
        pub struct __result_of_memfun_deref_impl {
            pub _bindgen_opaque_blob: u8,
        }
        #[test]
        fn bindgen_test_layout___result_of_memfun_deref_impl() {
            assert_eq!(
                ::std::mem::size_of::<__result_of_memfun_deref_impl>(),
                1usize,
                concat!("Size of: ", stringify!(__result_of_memfun_deref_impl))
            );
            assert_eq!(
                ::std::mem::align_of::<__result_of_memfun_deref_impl>(),
                1usize,
                concat!("Alignment of ", stringify!(__result_of_memfun_deref_impl))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __result_of_memfun_deref {
            pub _address: u8,
        }
        pub type __result_of_memfun_deref_type = u8;
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Debug, Copy, Clone)]
        pub struct __result_of_memobj_ref_impl {
            pub _bindgen_opaque_blob: u8,
        }
        #[test]
        fn bindgen_test_layout___result_of_memobj_ref_impl() {
            assert_eq!(
                ::std::mem::size_of::<__result_of_memobj_ref_impl>(),
                1usize,
                concat!("Size of: ", stringify!(__result_of_memobj_ref_impl))
            );
            assert_eq!(
                ::std::mem::align_of::<__result_of_memobj_ref_impl>(),
                1usize,
                concat!("Alignment of ", stringify!(__result_of_memobj_ref_impl))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __result_of_memobj_ref {
            pub _address: u8,
        }
        pub type __result_of_memobj_ref_type = u8;
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Debug, Copy, Clone)]
        pub struct __result_of_memobj_deref_impl {
            pub _bindgen_opaque_blob: u8,
        }
        #[test]
        fn bindgen_test_layout___result_of_memobj_deref_impl() {
            assert_eq!(
                ::std::mem::size_of::<__result_of_memobj_deref_impl>(),
                1usize,
                concat!("Size of: ", stringify!(__result_of_memobj_deref_impl))
            );
            assert_eq!(
                ::std::mem::align_of::<__result_of_memobj_deref_impl>(),
                1usize,
                concat!("Alignment of ", stringify!(__result_of_memobj_deref_impl))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __result_of_memobj_deref {
            pub _address: u8,
        }
        pub type __result_of_memobj_deref_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __result_of_memobj {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __result_of_memfun {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __inv_unwrap {
            pub _address: u8,
        }
        pub type __inv_unwrap_type = u8;
        pub type __result_of_impl_type = u8;
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Debug, Copy, Clone)]
        pub struct __result_of_other_impl {
            pub _bindgen_opaque_blob: u8,
        }
        #[test]
        fn bindgen_test_layout___result_of_other_impl() {
            assert_eq!(
                ::std::mem::size_of::<__result_of_other_impl>(),
                1usize,
                concat!("Size of: ", stringify!(__result_of_other_impl))
            );
            assert_eq!(
                ::std::mem::align_of::<__result_of_other_impl>(),
                1usize,
                concat!("Alignment of ", stringify!(__result_of_other_impl))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __invoke_result {
            pub _address: u8,
        }
        pub type aligned_storage_t = u8;
        pub type aligned_union_t = u8;
        pub type decay_t = u8;
        pub type enable_if_t = u8;
        pub type conditional_t = u8;
        pub type common_type_t = u8;
        pub type underlying_type_t = u8;
        pub type result_of_t = u8;
        pub type void_t = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __detector {
            pub _address: u8,
        }
        pub type __detector_type = u8;
        pub type __detector___is_detected = u8;
        pub type __detected_or = u8;
        pub type __detected_or_t = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __is_tuple_like_impl {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __is_tuple_like {
            pub _address: u8,
        }
        pub mod __swappable_details {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[repr(align(1))]
            #[derive(Debug, Copy, Clone)]
            pub struct __do_is_swappable_impl {
                pub _bindgen_opaque_blob: u8,
            }
            #[test]
            fn bindgen_test_layout___do_is_swappable_impl() {
                assert_eq!(
                    ::std::mem::size_of::<__do_is_swappable_impl>(),
                    1usize,
                    concat!("Size of: ", stringify!(__do_is_swappable_impl))
                );
                assert_eq!(
                    ::std::mem::align_of::<__do_is_swappable_impl>(),
                    1usize,
                    concat!("Alignment of ", stringify!(__do_is_swappable_impl))
                );
            }
            #[repr(C)]
            #[repr(align(1))]
            #[derive(Debug, Copy, Clone)]
            pub struct __do_is_nothrow_swappable_impl {
                pub _bindgen_opaque_blob: u8,
            }
            #[test]
            fn bindgen_test_layout___do_is_nothrow_swappable_impl() {
                assert_eq!(
                    ::std::mem::size_of::<__do_is_nothrow_swappable_impl>(),
                    1usize,
                    concat!("Size of: ", stringify!(__do_is_nothrow_swappable_impl))
                );
                assert_eq!(
                    ::std::mem::align_of::<__do_is_nothrow_swappable_impl>(),
                    1usize,
                    concat!("Alignment of ", stringify!(__do_is_nothrow_swappable_impl))
                );
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __is_swappable_impl {
            pub _address: u8,
        }
        pub type __is_swappable_impl_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __is_nothrow_swappable_impl {
            pub _address: u8,
        }
        pub type __is_nothrow_swappable_impl_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __is_swappable {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __is_nothrow_swappable {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_swappable {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_nothrow_swappable {
            pub _address: u8,
        }
        pub mod __swappable_with_details {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[repr(align(1))]
            #[derive(Debug, Copy, Clone)]
            pub struct __do_is_swappable_with_impl {
                pub _bindgen_opaque_blob: u8,
            }
            #[test]
            fn bindgen_test_layout___do_is_swappable_with_impl() {
                assert_eq!(
                    ::std::mem::size_of::<__do_is_swappable_with_impl>(),
                    1usize,
                    concat!("Size of: ", stringify!(__do_is_swappable_with_impl))
                );
                assert_eq!(
                    ::std::mem::align_of::<__do_is_swappable_with_impl>(),
                    1usize,
                    concat!("Alignment of ", stringify!(__do_is_swappable_with_impl))
                );
            }
            #[repr(C)]
            #[repr(align(1))]
            #[derive(Debug, Copy, Clone)]
            pub struct __do_is_nothrow_swappable_with_impl {
                pub _bindgen_opaque_blob: u8,
            }
            #[test]
            fn bindgen_test_layout___do_is_nothrow_swappable_with_impl() {
                assert_eq!(
                    ::std::mem::size_of::<__do_is_nothrow_swappable_with_impl>(),
                    1usize,
                    concat!("Size of: ", stringify!(__do_is_nothrow_swappable_with_impl))
                );
                assert_eq!(
                    ::std::mem::align_of::<__do_is_nothrow_swappable_with_impl>(),
                    1usize,
                    concat!(
                        "Alignment of ",
                        stringify!(__do_is_nothrow_swappable_with_impl)
                    )
                );
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __is_swappable_with_impl {
            pub _address: u8,
        }
        pub type __is_swappable_with_impl_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __is_nothrow_swappable_with_impl {
            pub _address: u8,
        }
        pub type __is_nothrow_swappable_with_impl_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_swappable_with {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_nothrow_swappable_with {
            pub _address: u8,
        }
        pub type __is_invocable_impl___nothrow_conv = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __is_invocable {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __call_is_nothrow {
            pub _address: u8,
        }
        pub type __call_is_nothrow_ = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __is_nothrow_invocable {
            pub _address: u8,
        }
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Debug, Copy, Clone)]
        pub struct __nonesuchbase {
            pub _bindgen_opaque_blob: u8,
        }
        #[test]
        fn bindgen_test_layout___nonesuchbase() {
            assert_eq!(
                ::std::mem::size_of::<__nonesuchbase>(),
                1usize,
                concat!("Size of: ", stringify!(__nonesuchbase))
            );
            assert_eq!(
                ::std::mem::align_of::<__nonesuchbase>(),
                1usize,
                concat!("Alignment of ", stringify!(__nonesuchbase))
            );
        }
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Debug, Copy, Clone)]
        pub struct __nonesuch {
            pub _bindgen_opaque_blob: u8,
        }
        #[test]
        fn bindgen_test_layout___nonesuch() {
            assert_eq!(
                ::std::mem::size_of::<__nonesuch>(),
                1usize,
                concat!("Size of: ", stringify!(__nonesuch))
            );
            assert_eq!(
                ::std::mem::align_of::<__nonesuch>(),
                1usize,
                concat!("Alignment of ", stringify!(__nonesuch))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct invoke_result {
            pub _address: u8,
        }
        pub type invoke_result_t = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_invocable {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_invocable_r {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_nothrow_invocable {
            pub _address: u8,
        }
        pub type __is_nt_invocable_impl = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_nothrow_invocable_r {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct has_unique_object_representations {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_aggregate {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __move_if_noexcept_cond {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct tuple_size {
            pub _address: u8,
        }
        pub type __enable_if_has_tuple_size = u8;
        pub type __tuple_element_t = u8;
        pub type tuple_element_t = u8;
        pub type _Build_index_tuple__IdxTuple = u8;
        pub type _Build_index_tuple___type = u8;
        pub type integer_sequence_value_type = u8;
        pub type make_integer_sequence = u8;
        pub type index_sequence = u8;
        pub type make_index_sequence = u8;
        pub type index_sequence_for = u8;
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Debug, Copy, Clone)]
        pub struct in_place_t {
            pub _bindgen_opaque_blob: u8,
        }
        #[test]
        fn bindgen_test_layout_in_place_t() {
            assert_eq!(
                ::std::mem::size_of::<in_place_t>(),
                1usize,
                concat!("Size of: ", stringify!(in_place_t))
            );
            assert_eq!(
                ::std::mem::align_of::<in_place_t>(),
                1usize,
                concat!("Alignment of ", stringify!(in_place_t))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZSt8in_place"]
            pub static in_place: root::std::in_place_t;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct in_place_type_t {
            pub _address: u8,
        }
        pub type __is_in_place_type = u8;
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Debug, Copy, Clone)]
        pub struct piecewise_construct_t {
            pub _bindgen_opaque_blob: u8,
        }
        #[test]
        fn bindgen_test_layout_piecewise_construct_t() {
            assert_eq!(
                ::std::mem::size_of::<piecewise_construct_t>(),
                1usize,
                concat!("Size of: ", stringify!(piecewise_construct_t))
            );
            assert_eq!(
                ::std::mem::align_of::<piecewise_construct_t>(),
                1usize,
                concat!("Alignment of ", stringify!(piecewise_construct_t))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZSt19piecewise_construct"]
            pub static piecewise_construct: root::std::piecewise_construct_t;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __pair_base {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct pair {
            pub _address: u8,
        }
        pub type pair_first_type = u8;
        pub type pair_second_type = u8;
        pub type pair__PCCP = u8;
        pub type pair__PCCFP = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct pair___zero_as_null_pointer_constant {
            pub _address: u8,
        }
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Debug, Copy, Clone)]
        pub struct input_iterator_tag {
            pub _bindgen_opaque_blob: u8,
        }
        #[test]
        fn bindgen_test_layout_input_iterator_tag() {
            assert_eq!(
                ::std::mem::size_of::<input_iterator_tag>(),
                1usize,
                concat!("Size of: ", stringify!(input_iterator_tag))
            );
            assert_eq!(
                ::std::mem::align_of::<input_iterator_tag>(),
                1usize,
                concat!("Alignment of ", stringify!(input_iterator_tag))
            );
        }
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Debug, Copy, Clone)]
        pub struct output_iterator_tag {
            pub _bindgen_opaque_blob: u8,
        }
        #[test]
        fn bindgen_test_layout_output_iterator_tag() {
            assert_eq!(
                ::std::mem::size_of::<output_iterator_tag>(),
                1usize,
                concat!("Size of: ", stringify!(output_iterator_tag))
            );
            assert_eq!(
                ::std::mem::align_of::<output_iterator_tag>(),
                1usize,
                concat!("Alignment of ", stringify!(output_iterator_tag))
            );
        }
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Debug, Copy, Clone)]
        pub struct forward_iterator_tag {
            pub _bindgen_opaque_blob: u8,
        }
        #[test]
        fn bindgen_test_layout_forward_iterator_tag() {
            assert_eq!(
                ::std::mem::size_of::<forward_iterator_tag>(),
                1usize,
                concat!("Size of: ", stringify!(forward_iterator_tag))
            );
            assert_eq!(
                ::std::mem::align_of::<forward_iterator_tag>(),
                1usize,
                concat!("Alignment of ", stringify!(forward_iterator_tag))
            );
        }
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Debug, Copy, Clone)]
        pub struct bidirectional_iterator_tag {
            pub _bindgen_opaque_blob: u8,
        }
        #[test]
        fn bindgen_test_layout_bidirectional_iterator_tag() {
            assert_eq!(
                ::std::mem::size_of::<bidirectional_iterator_tag>(),
                1usize,
                concat!("Size of: ", stringify!(bidirectional_iterator_tag))
            );
            assert_eq!(
                ::std::mem::align_of::<bidirectional_iterator_tag>(),
                1usize,
                concat!("Alignment of ", stringify!(bidirectional_iterator_tag))
            );
        }
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Debug, Copy, Clone)]
        pub struct random_access_iterator_tag {
            pub _bindgen_opaque_blob: u8,
        }
        #[test]
        fn bindgen_test_layout_random_access_iterator_tag() {
            assert_eq!(
                ::std::mem::size_of::<random_access_iterator_tag>(),
                1usize,
                concat!("Size of: ", stringify!(random_access_iterator_tag))
            );
            assert_eq!(
                ::std::mem::align_of::<random_access_iterator_tag>(),
                1usize,
                concat!("Alignment of ", stringify!(random_access_iterator_tag))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct iterator {
            pub _address: u8,
        }
        pub type iterator_iterator_category = u8;
        pub type iterator_value_type = u8;
        pub type iterator_difference_type = u8;
        pub type iterator_pointer = u8;
        pub type iterator_reference = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __iterator_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct iterator_traits {
            pub _address: u8,
        }
        pub type __iterator_category_t = u8;
        pub type _RequireInputIter = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __is_random_access_iter {
            pub _address: u8,
        }
        pub type __is_random_access_iter__Base = u8;
        pub const __is_random_access_iter___value:
            root::std::__is_random_access_iter__bindgen_ty_1 = 0;
        pub type __is_random_access_iter__bindgen_ty_1 = i32;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _List_iterator {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _List_const_iterator {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __undefined {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __get_first_arg {
            pub _address: u8,
        }
        pub type __get_first_arg_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __replace_first_arg {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __ptr_traits_elem {
            pub _address: u8,
        }
        pub type __ptr_traits_elem_t = u8;
        pub type __ptr_traits_ptr_to_pointer = u8;
        pub type __ptr_traits_ptr_to_element_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __ptr_traits_impl {
            pub _address: u8,
        }
        pub type __ptr_traits_impl___diff_t = u8;
        pub type __ptr_traits_impl___rebind = u8;
        pub type __ptr_traits_impl_pointer = u8;
        pub type __ptr_traits_impl_element_type = u8;
        pub type __ptr_traits_impl_difference_type = u8;
        pub type __ptr_traits_impl_rebind = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct pointer_traits {
            pub _address: u8,
        }
        pub type __ptr_rebind = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct reverse_iterator {
            pub _address: u8,
        }
        pub type reverse_iterator___traits_type = u8;
        pub type reverse_iterator_iterator_type = u8;
        pub type reverse_iterator_pointer = u8;
        pub type reverse_iterator_difference_type = u8;
        pub type reverse_iterator_reference = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct back_insert_iterator {
            pub _address: u8,
        }
        pub type back_insert_iterator_container_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct front_insert_iterator {
            pub _address: u8,
        }
        pub type front_insert_iterator_container_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct insert_iterator {
            pub _address: u8,
        }
        pub type insert_iterator__Iter = u8;
        pub type insert_iterator_container_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct move_iterator {
            pub _address: u8,
        }
        pub type move_iterator___traits_type = u8;
        pub type move_iterator___base_ref = u8;
        pub type move_iterator_iterator_type = u8;
        pub type move_iterator_iterator_category = u8;
        pub type move_iterator_value_type = u8;
        pub type move_iterator_difference_type = u8;
        pub type move_iterator_pointer = u8;
        pub type move_iterator_reference = u8;
        pub type __iter_key_t = u8;
        pub type __iter_val_t = u8;
        pub type __iter_to_alloc_t = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Deque_iterator {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct char_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct istreambuf_iterator {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ostreambuf_iterator {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __lc_rai {
            pub _address: u8,
        }
        #[repr(C)]
        #[repr(align(8))]
        #[derive(Debug, Copy, Clone)]
        pub struct exception {
            pub _bindgen_opaque_blob: u64,
        }
        #[test]
        fn bindgen_test_layout_exception() {
            assert_eq!(
                ::std::mem::size_of::<exception>(),
                8usize,
                concat!("Size of: ", stringify!(exception))
            );
            assert_eq!(
                ::std::mem::align_of::<exception>(),
                8usize,
                concat!("Alignment of ", stringify!(exception))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt9exceptionD1Ev"]
            pub fn exception_exception_destructor(this: *mut root::std::exception);
        }
        extern "C" {
            #[link_name = "\u{1}_ZNKSt9exception4whatEv"]
            pub fn exception_what(
                this: *mut ::std::os::raw::c_void,
            ) -> *const ::std::os::raw::c_char;
        }
        #[repr(C)]
        #[repr(align(8))]
        #[derive(Debug, Copy, Clone)]
        pub struct bad_alloc {
            pub _bindgen_opaque_blob: u64,
        }
        #[test]
        fn bindgen_test_layout_bad_alloc() {
            assert_eq!(
                ::std::mem::size_of::<bad_alloc>(),
                8usize,
                concat!("Size of: ", stringify!(bad_alloc))
            );
            assert_eq!(
                ::std::mem::align_of::<bad_alloc>(),
                8usize,
                concat!("Alignment of ", stringify!(bad_alloc))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt9bad_allocD1Ev"]
            pub fn bad_alloc_bad_alloc_destructor(this: *mut root::std::bad_alloc);
        }
        extern "C" {
            #[link_name = "\u{1}_ZNKSt9bad_alloc4whatEv"]
            pub fn bad_alloc_what(
                this: *mut ::std::os::raw::c_void,
            ) -> *const ::std::os::raw::c_char;
        }
        #[repr(C)]
        #[repr(align(8))]
        #[derive(Debug, Copy, Clone)]
        pub struct bad_array_new_length {
            pub _bindgen_opaque_blob: u64,
        }
        #[test]
        fn bindgen_test_layout_bad_array_new_length() {
            assert_eq!(
                ::std::mem::size_of::<bad_array_new_length>(),
                8usize,
                concat!("Size of: ", stringify!(bad_array_new_length))
            );
            assert_eq!(
                ::std::mem::align_of::<bad_array_new_length>(),
                8usize,
                concat!("Alignment of ", stringify!(bad_array_new_length))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt20bad_array_new_lengthD1Ev"]
            pub fn bad_array_new_length_bad_array_new_length_destructor(
                this: *mut root::std::bad_array_new_length,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNKSt20bad_array_new_length4whatEv"]
            pub fn bad_array_new_length_what(
                this: *mut ::std::os::raw::c_void,
            ) -> *const ::std::os::raw::c_char;
        }
        pub type align_val_t = usize;
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Debug, Copy, Clone)]
        pub struct nothrow_t {
            pub _bindgen_opaque_blob: u8,
        }
        #[test]
        fn bindgen_test_layout_nothrow_t() {
            assert_eq!(
                ::std::mem::size_of::<nothrow_t>(),
                1usize,
                concat!("Size of: ", stringify!(nothrow_t))
            );
            assert_eq!(
                ::std::mem::align_of::<nothrow_t>(),
                1usize,
                concat!("Alignment of ", stringify!(nothrow_t))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZSt7nothrow"]
            pub static nothrow: root::std::nothrow_t;
        }
        pub type new_handler = u64;
        extern "C" {
            #[link_name = "\u{1}_ZSt15set_new_handlerPFvvE"]
            pub fn set_new_handler(arg1: root::std::new_handler) -> root::std::new_handler;
        }
        extern "C" {
            #[link_name = "\u{1}_ZSt15get_new_handlerv"]
            pub fn get_new_handler() -> root::std::new_handler;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __new_allocator {
            pub _address: u8,
        }
        pub type __new_allocator_value_type = u8;
        pub type __new_allocator_size_type = u64;
        pub type __new_allocator_difference_type = u64;
        pub type __new_allocator_pointer = u8;
        pub type __new_allocator_const_pointer = u8;
        pub type __new_allocator_reference = u8;
        pub type __new_allocator_const_reference = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __new_allocator_rebind {
            pub _address: u8,
        }
        pub type __new_allocator_propagate_on_container_move_assignment = u8;
        pub type __allocator_base = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator {
            pub _address: u8,
        }
        pub type allocator_value_type = u8;
        pub type allocator_size_type = u64;
        pub type allocator_difference_type = u64;
        pub type allocator_pointer = u8;
        pub type allocator_const_pointer = u8;
        pub type allocator_reference = u8;
        pub type allocator_const_reference = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_rebind {
            pub _address: u8,
        }
        pub type allocator_rebind_other = u8;
        pub type allocator_propagate_on_container_move_assignment = u8;
        pub type allocator_is_always_equal = u8;
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Debug, Copy, Clone)]
        pub struct __allocator_traits_base {
            pub _bindgen_opaque_blob: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __allocator_traits_base___rebind {
            pub _address: u8,
        }
        pub type __allocator_traits_base___pointer = u8;
        pub type __allocator_traits_base___c_pointer = u8;
        pub type __allocator_traits_base___v_pointer = u8;
        pub type __allocator_traits_base___cv_pointer = u8;
        pub type __allocator_traits_base___pocca = u8;
        pub type __allocator_traits_base___pocma = u8;
        pub type __allocator_traits_base___pocs = u8;
        pub type __allocator_traits_base___equal = u8;
        #[test]
        fn bindgen_test_layout___allocator_traits_base() {
            assert_eq!(
                ::std::mem::size_of::<__allocator_traits_base>(),
                1usize,
                concat!("Size of: ", stringify!(__allocator_traits_base))
            );
            assert_eq!(
                ::std::mem::align_of::<__allocator_traits_base>(),
                1usize,
                concat!("Alignment of ", stringify!(__allocator_traits_base))
            );
        }
        pub type __alloc_rebind = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits {
            pub _address: u8,
        }
        pub type allocator_traits_allocator_type = u8;
        pub type allocator_traits_value_type = u8;
        pub type allocator_traits_pointer = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits__Ptr {
            pub _address: u8,
        }
        pub type allocator_traits__Ptr_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits__Diff {
            pub _address: u8,
        }
        pub type allocator_traits__Diff_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits__Size {
            pub _address: u8,
        }
        pub type allocator_traits_const_pointer = u8;
        pub type allocator_traits_void_pointer = u8;
        pub type allocator_traits_const_void_pointer = u8;
        pub type allocator_traits_difference_type = u8;
        pub type allocator_traits_size_type = u8;
        pub type allocator_traits_propagate_on_container_copy_assignment = u8;
        pub type allocator_traits_propagate_on_container_move_assignment = u8;
        pub type allocator_traits_propagate_on_container_swap = u8;
        pub type allocator_traits_is_always_equal = u8;
        pub type allocator_traits_rebind_alloc = u8;
        pub type allocator_traits_rebind_traits = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits___construct_helper {
            pub _address: u8,
        }
        pub type allocator_traits___construct_helper_type = u8;
        pub type allocator_traits___has_construct = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __is_alloc_insertable_impl {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __is_copy_insertable {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __is_move_insertable {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __is_allocator {
            pub _address: u8,
        }
        pub type _RequireAllocator = u8;
        pub type _RequireNotAllocator = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __is_bitwise_relocatable {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct initializer_list {
            pub _address: u8,
        }
        pub type initializer_list_value_type = u8;
        pub type initializer_list_reference = u8;
        pub type initializer_list_const_reference = u8;
        pub type initializer_list_size_type = u64;
        pub type initializer_list_iterator = u8;
        pub type initializer_list_const_iterator = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Vector_base {
            pub _address: u8,
        }
        pub type _Vector_base__Tp_alloc_type = u8;
        pub type _Vector_base_pointer = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Vector_base__Vector_impl_data {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Vector_base__Vector_impl {
            pub _address: u8,
        }
        pub type _Vector_base_allocator_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct vector {
            pub _address: u8,
        }
        pub type vector__Base = u8;
        pub type vector__Tp_alloc_type = u8;
        pub type vector__Alloc_traits = u8;
        pub type vector_value_type = u8;
        pub type vector_pointer = u8;
        pub type vector_const_pointer = u8;
        pub type vector_reference = u8;
        pub type vector_const_reference = u8;
        pub type vector_iterator = u8;
        pub type vector_const_iterator = u8;
        pub type vector_const_reverse_iterator = u8;
        pub type vector_reverse_iterator = u8;
        pub type vector_size_type = u64;
        pub type vector_difference_type = u64;
        pub type vector_allocator_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct vector__Temporary_value {
            pub _address: u8,
        }
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Copy, Clone)]
        pub union vector__Temporary_value__Storage {
            pub _bindgen_opaque_blob: u8,
        }
        extern "C" {
            #[link_name = "\u{1}_ZSt11_Hash_bytesPKvyy"]
            pub fn _Hash_bytes(
                __ptr: *const ::std::os::raw::c_void,
                __len: usize,
                __seed: usize,
            ) -> usize;
        }
        extern "C" {
            #[link_name = "\u{1}_ZSt15_Fnv_hash_bytesPKvyy"]
            pub fn _Fnv_hash_bytes(
                __ptr: *const ::std::os::raw::c_void,
                __len: usize,
                __seed: usize,
            ) -> usize;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __hash_base {
            pub _address: u8,
        }
        pub type __hash_base_result_type = u8;
        pub type __hash_base_argument_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __poison_hash {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct hash {
            pub _address: u8,
        }
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Debug, Copy, Clone)]
        pub struct _Hash_impl {
            pub _bindgen_opaque_blob: u8,
        }
        #[test]
        fn bindgen_test_layout__Hash_impl() {
            assert_eq!(
                ::std::mem::size_of::<_Hash_impl>(),
                1usize,
                concat!("Size of: ", stringify!(_Hash_impl))
            );
            assert_eq!(
                ::std::mem::align_of::<_Hash_impl>(),
                1usize,
                concat!("Alignment of ", stringify!(_Hash_impl))
            );
        }
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Debug, Copy, Clone)]
        pub struct _Fnv_hash_impl {
            pub _bindgen_opaque_blob: u8,
        }
        #[test]
        fn bindgen_test_layout__Fnv_hash_impl() {
            assert_eq!(
                ::std::mem::size_of::<_Fnv_hash_impl>(),
                1usize,
                concat!("Size of: ", stringify!(_Fnv_hash_impl))
            );
            assert_eq!(
                ::std::mem::align_of::<_Fnv_hash_impl>(),
                1usize,
                concat!("Alignment of ", stringify!(_Fnv_hash_impl))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __is_fast_hash {
            pub _address: u8,
        }
        pub type _Bit_type = u32;
        pub const std__S_word_bit: root::std::_bindgen_ty_1 = 32;
        pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
        #[repr(C)]
        #[repr(align(8))]
        #[derive(Debug, Copy, Clone)]
        pub struct _Bit_reference {
            pub _bindgen_opaque_blob: [u64; 2usize],
        }
        #[test]
        fn bindgen_test_layout__Bit_reference() {
            assert_eq!(
                ::std::mem::size_of::<_Bit_reference>(),
                16usize,
                concat!("Size of: ", stringify!(_Bit_reference))
            );
            assert_eq!(
                ::std::mem::align_of::<_Bit_reference>(),
                8usize,
                concat!("Alignment of ", stringify!(_Bit_reference))
            );
        }
        #[repr(C)]
        #[repr(align(8))]
        #[derive(Debug, Copy, Clone)]
        pub struct _Bit_iterator_base {
            pub _bindgen_opaque_blob: [u64; 2usize],
        }
        #[test]
        fn bindgen_test_layout__Bit_iterator_base() {
            assert_eq!(
                ::std::mem::size_of::<_Bit_iterator_base>(),
                16usize,
                concat!("Size of: ", stringify!(_Bit_iterator_base))
            );
            assert_eq!(
                ::std::mem::align_of::<_Bit_iterator_base>(),
                8usize,
                concat!("Alignment of ", stringify!(_Bit_iterator_base))
            );
        }
        #[repr(C)]
        #[repr(align(8))]
        #[derive(Debug, Copy, Clone)]
        pub struct _Bit_iterator {
            pub _bindgen_opaque_blob: [u64; 2usize],
        }
        pub type _Bit_iterator_reference = [u64; 2usize];
        pub type _Bit_iterator_pointer = u64;
        #[test]
        fn bindgen_test_layout__Bit_iterator() {
            assert_eq!(
                ::std::mem::size_of::<_Bit_iterator>(),
                16usize,
                concat!("Size of: ", stringify!(_Bit_iterator))
            );
            assert_eq!(
                ::std::mem::align_of::<_Bit_iterator>(),
                8usize,
                concat!("Alignment of ", stringify!(_Bit_iterator))
            );
        }
        #[repr(C)]
        #[repr(align(8))]
        #[derive(Debug, Copy, Clone)]
        pub struct _Bit_const_iterator {
            pub _bindgen_opaque_blob: [u64; 2usize],
        }
        pub type _Bit_const_iterator_reference = u8;
        pub type _Bit_const_iterator_const_reference = u8;
        pub type _Bit_const_iterator_pointer = u64;
        #[test]
        fn bindgen_test_layout__Bit_const_iterator() {
            assert_eq!(
                ::std::mem::size_of::<_Bit_const_iterator>(),
                16usize,
                concat!("Size of: ", stringify!(_Bit_const_iterator))
            );
            assert_eq!(
                ::std::mem::align_of::<_Bit_const_iterator>(),
                8usize,
                concat!("Alignment of ", stringify!(_Bit_const_iterator))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Bvector_base {
            pub _address: u8,
        }
        pub type _Bvector_base__Bit_alloc_type = u8;
        pub type _Bvector_base__Bit_alloc_traits = u8;
        pub type _Bvector_base__Bit_pointer = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Bvector_base__Bvector_impl_data {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Bvector_base__Bvector_impl {
            pub _address: u8,
        }
        pub type _Bvector_base_allocator_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct unary_function {
            pub _address: u8,
        }
        pub type unary_function_argument_type = u8;
        pub type unary_function_result_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct binary_function {
            pub _address: u8,
        }
        pub type binary_function_first_argument_type = u8;
        pub type binary_function_second_argument_type = u8;
        pub type binary_function_result_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __is_transparent {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct plus {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct minus {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct multiplies {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct divides {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct modulus {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct negate {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct equal_to {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct not_equal_to {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct greater {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct less {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct greater_equal {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct less_equal {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct logical_and {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct logical_or {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct logical_not {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct bit_and {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct bit_or {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct bit_xor {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct bit_not {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct unary_negate {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct binary_negate {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct pointer_to_unary_function {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct pointer_to_binary_function {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Identity {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Select1st {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Select2nd {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct mem_fun_t {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct const_mem_fun_t {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct mem_fun_ref_t {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct const_mem_fun_ref_t {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct mem_fun1_t {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct const_mem_fun1_t {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct mem_fun1_ref_t {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct const_mem_fun1_ref_t {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __has_is_transparent {
            pub _address: u8,
        }
        pub type __has_is_transparent_t = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct binder1st {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct binder2nd {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Maybe_unary_or_binary_function {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Mem_fn_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Mem_fn_traits_base {
            pub _address: u8,
        }
        pub type _Mem_fn_traits_base___result_type = u8;
        pub type _Mem_fn_traits_base___maybe_type = u8;
        pub type _Mem_fn_traits_base___arity = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Maybe_get_result_type {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Weak_result_type_impl {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Weak_result_type {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Refwrap_base_arg1 {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Refwrap_base_arg2 {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Reference_wrapper_base {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct reference_wrapper {
            pub _address: u8,
        }
        pub type reference_wrapper___not_same = u8;
        pub type reference_wrapper_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct valarray {
            pub _address: u8,
        }
        pub type byte = ::std::os::raw::c_uchar;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __byte_operand {
            pub _address: u8,
        }
        pub type __byte_op_t = u8;
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Debug, Copy, Clone)]
        pub struct __erased_type {
            pub _bindgen_opaque_blob: u8,
        }
        #[test]
        fn bindgen_test_layout___erased_type() {
            assert_eq!(
                ::std::mem::size_of::<__erased_type>(),
                1usize,
                concat!("Size of: ", stringify!(__erased_type))
            );
            assert_eq!(
                ::std::mem::align_of::<__erased_type>(),
                1usize,
                concat!("Alignment of ", stringify!(__erased_type))
            );
        }
        pub type __is_erased_or_convertible = u8;
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_arg_t {
            pub _bindgen_opaque_blob: u8,
        }
        #[test]
        fn bindgen_test_layout_allocator_arg_t() {
            assert_eq!(
                ::std::mem::size_of::<allocator_arg_t>(),
                1usize,
                concat!("Size of: ", stringify!(allocator_arg_t))
            );
            assert_eq!(
                ::std::mem::align_of::<allocator_arg_t>(),
                1usize,
                concat!("Alignment of ", stringify!(allocator_arg_t))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZSt13allocator_arg"]
            pub static allocator_arg: root::std::allocator_arg_t;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __uses_allocator_helper {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct uses_allocator {
            pub _address: u8,
        }
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Debug, Copy, Clone)]
        pub struct __uses_alloc_base {
            pub _bindgen_opaque_blob: u8,
        }
        #[test]
        fn bindgen_test_layout___uses_alloc_base() {
            assert_eq!(
                ::std::mem::size_of::<__uses_alloc_base>(),
                1usize,
                concat!("Size of: ", stringify!(__uses_alloc_base))
            );
            assert_eq!(
                ::std::mem::align_of::<__uses_alloc_base>(),
                1usize,
                concat!("Alignment of ", stringify!(__uses_alloc_base))
            );
        }
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Debug, Copy, Clone)]
        pub struct __uses_alloc0 {
            pub _bindgen_opaque_blob: u8,
        }
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Debug, Copy, Clone)]
        pub struct __uses_alloc0__Sink {
            pub _bindgen_opaque_blob: u8,
        }
        #[test]
        fn bindgen_test_layout___uses_alloc0__Sink() {
            assert_eq!(
                ::std::mem::size_of::<__uses_alloc0__Sink>(),
                1usize,
                concat!("Size of: ", stringify!(__uses_alloc0__Sink))
            );
            assert_eq!(
                ::std::mem::align_of::<__uses_alloc0__Sink>(),
                1usize,
                concat!("Alignment of ", stringify!(__uses_alloc0__Sink))
            );
        }
        #[test]
        fn bindgen_test_layout___uses_alloc0() {
            assert_eq!(
                ::std::mem::size_of::<__uses_alloc0>(),
                1usize,
                concat!("Size of: ", stringify!(__uses_alloc0))
            );
            assert_eq!(
                ::std::mem::align_of::<__uses_alloc0>(),
                1usize,
                concat!("Alignment of ", stringify!(__uses_alloc0))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __uses_alloc1 {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __uses_alloc2 {
            pub _address: u8,
        }
        pub type __uses_alloc_t = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __is_uses_allocator_predicate {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __is_uses_allocator_constructible {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __is_nothrow_uses_allocator_constructible {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __is_empty_non_tuple {
            pub _address: u8,
        }
        pub type __empty_not_final = u8;
        pub type _TupleConstraints___constructible = u8;
        pub type _TupleConstraints___convertible = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct tuple {
            pub _address: u8,
        }
        pub type tuple__Inherited = u8;
        pub type tuple__TCC = u8;
        pub type tuple__ImplicitDefaultCtor = u8;
        pub type tuple__ExplicitDefaultCtor = u8;
        pub type tuple__ImplicitCtor = u8;
        pub type tuple__ExplicitCtor = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct tuple__UseOtherCtor {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __do_make_tuple {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __make_tuple {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __combine_tuples {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __tuple_cat_result {
            pub _address: u8,
        }
        pub type __tuple_cat_result___type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __make_1st_indices {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __tuple_concater {
            pub _address: u8,
        }
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Debug, Copy, Clone)]
        pub struct _Swallow_assign {
            pub _bindgen_opaque_blob: u8,
        }
        #[test]
        fn bindgen_test_layout__Swallow_assign() {
            assert_eq!(
                ::std::mem::size_of::<_Swallow_assign>(),
                1usize,
                concat!("Size of: ", stringify!(_Swallow_assign))
            );
            assert_eq!(
                ::std::mem::align_of::<_Swallow_assign>(),
                1usize,
                concat!("Alignment of ", stringify!(_Swallow_assign))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZSt6ignore"]
            pub static ignore: root::std::_Swallow_assign;
        }
        pub mod pmr {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[repr(align(8))]
            #[derive(Debug, Copy, Clone)]
            pub struct memory_resource {
                pub _bindgen_opaque_blob: u64,
            }
            #[test]
            fn bindgen_test_layout_memory_resource() {
                assert_eq!(
                    ::std::mem::size_of::<memory_resource>(),
                    8usize,
                    concat!("Size of: ", stringify!(memory_resource))
                );
                assert_eq!(
                    ::std::mem::align_of::<memory_resource>(),
                    8usize,
                    concat!("Alignment of ", stringify!(memory_resource))
                );
            }
            pub const memory_resource__S_max_align: usize = 16;
            extern "C" {
                #[link_name = "\u{1}_ZNSt3pmr15memory_resourceD1Ev"]
                pub fn memory_resource_memory_resource_destructor(
                    this: *mut root::std::pmr::memory_resource,
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct polymorphic_allocator {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct polymorphic_allocator___not_pair {
                pub _address: u8,
            }
            pub type polymorphic_allocator___not_pair_type = u8;
            pub type polymorphic_allocator_value_type = u8;
            pub type polymorphic_allocator___uses_alloc1_ = u8;
            pub type polymorphic_allocator___uses_alloc2_ = u8;
            pub type vector = u8;
        }
        pub const float_round_style_round_indeterminate: root::std::float_round_style = -1;
        pub const float_round_style_round_toward_zero: root::std::float_round_style = 0;
        pub const float_round_style_round_to_nearest: root::std::float_round_style = 1;
        pub const float_round_style_round_toward_infinity: root::std::float_round_style = 2;
        pub const float_round_style_round_toward_neg_infinity: root::std::float_round_style = 3;
        pub type float_round_style = ::std::os::raw::c_int;
        pub const float_denorm_style_denorm_indeterminate: root::std::float_denorm_style = -1;
        pub const float_denorm_style_denorm_absent: root::std::float_denorm_style = 0;
        pub const float_denorm_style_denorm_present: root::std::float_denorm_style = 1;
        pub type float_denorm_style = ::std::os::raw::c_int;
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Debug, Copy, Clone)]
        pub struct __numeric_limits_base {
            pub _bindgen_opaque_blob: u8,
        }
        #[test]
        fn bindgen_test_layout___numeric_limits_base() {
            assert_eq!(
                ::std::mem::size_of::<__numeric_limits_base>(),
                1usize,
                concat!("Size of: ", stringify!(__numeric_limits_base))
            );
            assert_eq!(
                ::std::mem::align_of::<__numeric_limits_base>(),
                1usize,
                concat!("Alignment of ", stringify!(__numeric_limits_base))
            );
        }
        pub const __numeric_limits_base_is_specialized: bool = false;
        pub const __numeric_limits_base_digits: ::std::os::raw::c_int = 0;
        pub const __numeric_limits_base_digits10: ::std::os::raw::c_int = 0;
        pub const __numeric_limits_base_max_digits10: ::std::os::raw::c_int = 0;
        pub const __numeric_limits_base_is_signed: bool = false;
        pub const __numeric_limits_base_is_integer: bool = false;
        pub const __numeric_limits_base_is_exact: bool = false;
        pub const __numeric_limits_base_radix: ::std::os::raw::c_int = 0;
        pub const __numeric_limits_base_min_exponent: ::std::os::raw::c_int = 0;
        pub const __numeric_limits_base_min_exponent10: ::std::os::raw::c_int = 0;
        pub const __numeric_limits_base_max_exponent: ::std::os::raw::c_int = 0;
        pub const __numeric_limits_base_max_exponent10: ::std::os::raw::c_int = 0;
        pub const __numeric_limits_base_has_infinity: bool = false;
        pub const __numeric_limits_base_has_quiet_NaN: bool = false;
        pub const __numeric_limits_base_has_signaling_NaN: bool = false;
        extern "C" {
            #[link_name = "\u{1}_ZNSt21__numeric_limits_base10has_denormE"]
            pub static __numeric_limits_base_has_denorm: root::std::float_denorm_style;
        }
        pub const __numeric_limits_base_has_denorm_loss: bool = false;
        pub const __numeric_limits_base_is_iec559: bool = false;
        pub const __numeric_limits_base_is_bounded: bool = false;
        pub const __numeric_limits_base_is_modulo: bool = false;
        pub const __numeric_limits_base_traps: bool = false;
        pub const __numeric_limits_base_tinyness_before: bool = false;
        extern "C" {
            #[link_name = "\u{1}_ZNSt21__numeric_limits_base11round_styleE"]
            pub static __numeric_limits_base_round_style: root::std::float_round_style;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct numeric_limits {
            pub _address: u8,
        }
    }
    pub mod __gnu_cxx {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub type __conditional_type___type<_Iftrue> = _Iftrue;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __add_unsigned {
            pub _address: u8,
        }
        pub type __add_unsigned___if_type = u8;
        pub type __add_unsigned___type = root::__gnu_cxx::__add_unsigned___if_type;
        #[test]
        fn __bindgen_test_layout___add_unsigned_open0_char_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::__gnu_cxx::__add_unsigned>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::__gnu_cxx::__add_unsigned)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::__gnu_cxx::__add_unsigned>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::__gnu_cxx::__add_unsigned)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout___add_unsigned_open0_signed_char_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::__gnu_cxx::__add_unsigned>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::__gnu_cxx::__add_unsigned)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::__gnu_cxx::__add_unsigned>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::__gnu_cxx::__add_unsigned)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout___add_unsigned_open0_short_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::__gnu_cxx::__add_unsigned>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::__gnu_cxx::__add_unsigned)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::__gnu_cxx::__add_unsigned>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::__gnu_cxx::__add_unsigned)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout___add_unsigned_open0_int_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::__gnu_cxx::__add_unsigned>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::__gnu_cxx::__add_unsigned)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::__gnu_cxx::__add_unsigned>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::__gnu_cxx::__add_unsigned)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout___add_unsigned_open0_long_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::__gnu_cxx::__add_unsigned>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::__gnu_cxx::__add_unsigned)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::__gnu_cxx::__add_unsigned>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::__gnu_cxx::__add_unsigned)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout___add_unsigned_open0_long_long_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::__gnu_cxx::__add_unsigned>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::__gnu_cxx::__add_unsigned)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::__gnu_cxx::__add_unsigned>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::__gnu_cxx::__add_unsigned)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __remove_unsigned {
            pub _address: u8,
        }
        pub type __remove_unsigned___if_type = u8;
        pub type __remove_unsigned___type = root::__gnu_cxx::__remove_unsigned___if_type;
        #[test]
        fn __bindgen_test_layout___remove_unsigned_open0_char_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::__gnu_cxx::__remove_unsigned>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::__gnu_cxx::__remove_unsigned)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::__gnu_cxx::__remove_unsigned>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::__gnu_cxx::__remove_unsigned)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout___remove_unsigned_open0_unsigned_char_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::__gnu_cxx::__remove_unsigned>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::__gnu_cxx::__remove_unsigned)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::__gnu_cxx::__remove_unsigned>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::__gnu_cxx::__remove_unsigned)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout___remove_unsigned_open0_unsigned_short_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::__gnu_cxx::__remove_unsigned>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::__gnu_cxx::__remove_unsigned)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::__gnu_cxx::__remove_unsigned>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::__gnu_cxx::__remove_unsigned)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout___remove_unsigned_open0_unsigned_int_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::__gnu_cxx::__remove_unsigned>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::__gnu_cxx::__remove_unsigned)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::__gnu_cxx::__remove_unsigned>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::__gnu_cxx::__remove_unsigned)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout___remove_unsigned_open0_unsigned_long_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::__gnu_cxx::__remove_unsigned>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::__gnu_cxx::__remove_unsigned)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::__gnu_cxx::__remove_unsigned>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::__gnu_cxx::__remove_unsigned)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout___remove_unsigned_open0_unsigned_long_long_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::__gnu_cxx::__remove_unsigned>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::__gnu_cxx::__remove_unsigned)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::__gnu_cxx::__remove_unsigned>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::__gnu_cxx::__remove_unsigned)
                )
            );
        }
        pub type __promote___type = f64;
        pub type __promoted_t = u8;
        pub type __promote_2 = u8;
        pub type __promote_3 = u8;
        pub type __promote_4 = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __is_integer_nonstrict {
            pub _address: u8,
        }
        pub const __is_integer_nonstrict___width:
            root::__gnu_cxx::__is_integer_nonstrict__bindgen_ty_1 = 0;
        pub type __is_integer_nonstrict__bindgen_ty_1 = i32;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __numeric_traits_integer {
            pub _address: u8,
        }
        extern "C" {
            pub static __is_signed: bool;
        }
        extern "C" {
            pub static __digits: ::std::os::raw::c_int;
        }
        pub type __int_traits = root::__gnu_cxx::__numeric_traits_integer;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __numeric_traits_floating {
            pub _address: u8,
        }
        extern "C" {
            pub static __max_digits10: ::std::os::raw::c_int;
        }
        extern "C" {
            pub static __digits10: ::std::os::raw::c_int;
        }
        extern "C" {
            pub static __max_exponent10: ::std::os::raw::c_int;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __numeric_traits {
            pub _address: u8,
        }
        #[test]
        fn __bindgen_test_layout___numeric_traits_open0_float_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::__gnu_cxx::__numeric_traits>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::__gnu_cxx::__numeric_traits)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::__gnu_cxx::__numeric_traits>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::__gnu_cxx::__numeric_traits)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout___numeric_traits_open0_double_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::__gnu_cxx::__numeric_traits>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::__gnu_cxx::__numeric_traits)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::__gnu_cxx::__numeric_traits>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::__gnu_cxx::__numeric_traits)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout___numeric_traits_open0_long_double_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::__gnu_cxx::__numeric_traits>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::__gnu_cxx::__numeric_traits)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::__gnu_cxx::__numeric_traits>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::__gnu_cxx::__numeric_traits)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __normal_iterator<_Iterator> {
            pub _M_current: _Iterator,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
        }
        pub type __normal_iterator___traits_type = u8;
        pub type __normal_iterator___convertible_from = root::std::__enable_if_t;
        pub type __normal_iterator_iterator_type<_Iterator> = _Iterator;
        pub type __normal_iterator_iterator_category =
            root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_value_type = root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_difference_type =
            root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_reference = root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_pointer = root::__gnu_cxx::__normal_iterator___traits_type;
        pub mod __ops {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct _Iter_less_iter {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout__Iter_less_iter() {
                assert_eq!(
                    ::std::mem::size_of::<_Iter_less_iter>(),
                    1usize,
                    concat!("Size of: ", stringify!(_Iter_less_iter))
                );
                assert_eq!(
                    ::std::mem::align_of::<_Iter_less_iter>(),
                    1usize,
                    concat!("Alignment of ", stringify!(_Iter_less_iter))
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct _Iter_less_val {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout__Iter_less_val() {
                assert_eq!(
                    ::std::mem::size_of::<_Iter_less_val>(),
                    1usize,
                    concat!("Size of: ", stringify!(_Iter_less_val))
                );
                assert_eq!(
                    ::std::mem::align_of::<_Iter_less_val>(),
                    1usize,
                    concat!("Alignment of ", stringify!(_Iter_less_val))
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct _Val_less_iter {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout__Val_less_iter() {
                assert_eq!(
                    ::std::mem::size_of::<_Val_less_iter>(),
                    1usize,
                    concat!("Size of: ", stringify!(_Val_less_iter))
                );
                assert_eq!(
                    ::std::mem::align_of::<_Val_less_iter>(),
                    1usize,
                    concat!("Alignment of ", stringify!(_Val_less_iter))
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct _Iter_equal_to_iter {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout__Iter_equal_to_iter() {
                assert_eq!(
                    ::std::mem::size_of::<_Iter_equal_to_iter>(),
                    1usize,
                    concat!("Size of: ", stringify!(_Iter_equal_to_iter))
                );
                assert_eq!(
                    ::std::mem::align_of::<_Iter_equal_to_iter>(),
                    1usize,
                    concat!("Alignment of ", stringify!(_Iter_equal_to_iter))
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct _Iter_equal_to_val {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout__Iter_equal_to_val() {
                assert_eq!(
                    ::std::mem::size_of::<_Iter_equal_to_val>(),
                    1usize,
                    concat!("Size of: ", stringify!(_Iter_equal_to_val))
                );
                assert_eq!(
                    ::std::mem::align_of::<_Iter_equal_to_val>(),
                    1usize,
                    concat!("Alignment of ", stringify!(_Iter_equal_to_val))
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct _Iter_comp_iter<_Compare> {
                pub _M_comp: _Compare,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Compare>>,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct _Iter_comp_val<_Compare> {
                pub _M_comp: _Compare,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Compare>>,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct _Val_comp_iter<_Compare> {
                pub _M_comp: _Compare,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Compare>>,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct _Iter_equals_val<_Value> {
                pub _M_value: *mut _Value,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Value>>,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct _Iter_equals_iter<_Iterator1> {
                pub _M_it1: _Iterator1,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator1>>,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct _Iter_pred<_Predicate> {
                pub _M_pred: _Predicate,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Predicate>>,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct _Iter_comp_to_val<_Compare, _Value> {
                pub _M_comp: _Compare,
                pub _M_value: *mut _Value,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Compare>>,
                pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Value>>,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct _Iter_comp_to_iter<_Compare, _Iterator1> {
                pub _M_comp: _Compare,
                pub _M_it1: _Iterator1,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Compare>>,
                pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator1>>,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct _Iter_negate<_Predicate> {
                pub _M_pred: _Predicate,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Predicate>>,
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __alloc_traits {
            pub _address: u8,
        }
        pub type __alloc_traits_allocator_type<_Alloc> = _Alloc;
        pub type __alloc_traits__Base_type = u8;
        pub type __alloc_traits_value_type = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_pointer = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_const_pointer = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_size_type = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_difference_type = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_reference = *mut root::__gnu_cxx::__alloc_traits_value_type;
        pub type __alloc_traits_const_reference = *const root::__gnu_cxx::__alloc_traits_value_type;
        pub type __alloc_traits___is_custom_pointer = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __alloc_traits_rebind {
            pub _address: u8,
        }
        pub type __alloc_traits_rebind_other = root::__gnu_cxx::__alloc_traits__Base_type;
    }
    pub mod __gnu_debug {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Safe_iterator {
            pub _address: u8,
        }
    }
    #[repr(C)]
    #[repr(align(16))]
    #[derive(Debug, Copy, Clone)]
    pub struct max_align_t {
        pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
        pub __bindgen_padding_0: u64,
        pub __clang_max_align_nonce2: u128,
    }
    #[test]
    fn bindgen_test_layout_max_align_t() {
        const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<max_align_t>(),
            32usize,
            concat!("Size of: ", stringify!(max_align_t))
        );
        assert_eq!(
            ::std::mem::align_of::<max_align_t>(),
            16usize,
            concat!("Alignment of ", stringify!(max_align_t))
        );
        assert_eq!(
            unsafe {
                ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(max_align_t),
                "::",
                stringify!(__clang_max_align_nonce1)
            )
        );
        assert_eq!(
            unsafe {
                ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(max_align_t),
                "::",
                stringify!(__clang_max_align_nonce2)
            )
        );
    }
    pub type __gnuc_va_list = root::__builtin_va_list;
    pub type va_list = root::__gnuc_va_list;
    pub type rsize_t = usize;
    pub type wint_t = ::std::os::raw::c_ushort;
    pub type wctype_t = ::std::os::raw::c_ushort;
    pub type errno_t = ::std::os::raw::c_int;
    pub type __time32_t = ::std::os::raw::c_long;
    pub type __time64_t = ::std::os::raw::c_longlong;
    pub type time_t = root::__time64_t;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct threadmbcinfostruct {
        _unused: [u8; 0],
    }
    pub type pthreadlocinfo = *mut root::threadlocaleinfostruct;
    pub type pthreadmbcinfo = *mut root::threadmbcinfostruct;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct __lc_time_data {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct localeinfo_struct {
        pub locinfo: root::pthreadlocinfo,
        pub mbcinfo: root::pthreadmbcinfo,
    }
    #[test]
    fn bindgen_test_layout_localeinfo_struct() {
        const UNINIT: ::std::mem::MaybeUninit<localeinfo_struct> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<localeinfo_struct>(),
            16usize,
            concat!("Size of: ", stringify!(localeinfo_struct))
        );
        assert_eq!(
            ::std::mem::align_of::<localeinfo_struct>(),
            8usize,
            concat!("Alignment of ", stringify!(localeinfo_struct))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).locinfo) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(localeinfo_struct),
                "::",
                stringify!(locinfo)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).mbcinfo) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(localeinfo_struct),
                "::",
                stringify!(mbcinfo)
            )
        );
    }
    pub type _locale_tstruct = root::localeinfo_struct;
    pub type _locale_t = *mut root::localeinfo_struct;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct tagLC_ID {
        pub wLanguage: ::std::os::raw::c_ushort,
        pub wCountry: ::std::os::raw::c_ushort,
        pub wCodePage: ::std::os::raw::c_ushort,
    }
    #[test]
    fn bindgen_test_layout_tagLC_ID() {
        const UNINIT: ::std::mem::MaybeUninit<tagLC_ID> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<tagLC_ID>(),
            6usize,
            concat!("Size of: ", stringify!(tagLC_ID))
        );
        assert_eq!(
            ::std::mem::align_of::<tagLC_ID>(),
            2usize,
            concat!("Alignment of ", stringify!(tagLC_ID))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).wLanguage) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(tagLC_ID),
                "::",
                stringify!(wLanguage)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).wCountry) as usize - ptr as usize },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(tagLC_ID),
                "::",
                stringify!(wCountry)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).wCodePage) as usize - ptr as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(tagLC_ID),
                "::",
                stringify!(wCodePage)
            )
        );
    }
    pub type LC_ID = root::tagLC_ID;
    pub type LPLC_ID = *mut root::tagLC_ID;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct threadlocaleinfostruct {
        pub _locale_pctype: *const ::std::os::raw::c_ushort,
        pub _locale_mb_cur_max: ::std::os::raw::c_int,
        pub _locale_lc_codepage: ::std::os::raw::c_uint,
    }
    #[test]
    fn bindgen_test_layout_threadlocaleinfostruct() {
        const UNINIT: ::std::mem::MaybeUninit<threadlocaleinfostruct> =
            ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<threadlocaleinfostruct>(),
            16usize,
            concat!("Size of: ", stringify!(threadlocaleinfostruct))
        );
        assert_eq!(
            ::std::mem::align_of::<threadlocaleinfostruct>(),
            8usize,
            concat!("Alignment of ", stringify!(threadlocaleinfostruct))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr)._locale_pctype) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(threadlocaleinfostruct),
                "::",
                stringify!(_locale_pctype)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr)._locale_mb_cur_max) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(threadlocaleinfostruct),
                "::",
                stringify!(_locale_mb_cur_max)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr)._locale_lc_codepage) as usize - ptr as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(threadlocaleinfostruct),
                "::",
                stringify!(_locale_lc_codepage)
            )
        );
    }
    pub type threadlocinfo = root::threadlocaleinfostruct;
    extern "C" {
        pub static _HUGE: f64;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _exception {
        pub type_: ::std::os::raw::c_int,
        pub name: *const ::std::os::raw::c_char,
        pub arg1: f64,
        pub arg2: f64,
        pub retval: f64,
    }
    #[test]
    fn bindgen_test_layout__exception() {
        const UNINIT: ::std::mem::MaybeUninit<_exception> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<_exception>(),
            40usize,
            concat!("Size of: ", stringify!(_exception))
        );
        assert_eq!(
            ::std::mem::align_of::<_exception>(),
            8usize,
            concat!("Alignment of ", stringify!(_exception))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_exception),
                "::",
                stringify!(type_)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_exception),
                "::",
                stringify!(name)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).arg1) as usize - ptr as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_exception),
                "::",
                stringify!(arg1)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).arg2) as usize - ptr as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_exception),
                "::",
                stringify!(arg2)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).retval) as usize - ptr as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_exception),
                "::",
                stringify!(retval)
            )
        );
    }
    extern "C" {
        pub fn __setusermatherr(
            arg1: ::std::option::Option<
                unsafe extern "C" fn(arg1: *mut root::_exception) -> ::std::os::raw::c_int,
            >,
        );
    }
    extern "C" {
        pub fn sin(_X: f64) -> f64;
    }
    extern "C" {
        pub fn cos(_X: f64) -> f64;
    }
    extern "C" {
        pub fn tan(_X: f64) -> f64;
    }
    extern "C" {
        pub fn sinh(_X: f64) -> f64;
    }
    extern "C" {
        pub fn cosh(_X: f64) -> f64;
    }
    extern "C" {
        pub fn tanh(_X: f64) -> f64;
    }
    extern "C" {
        pub fn asin(_X: f64) -> f64;
    }
    extern "C" {
        pub fn acos(_X: f64) -> f64;
    }
    extern "C" {
        pub fn atan(_X: f64) -> f64;
    }
    extern "C" {
        pub fn atan2(_Y: f64, _X: f64) -> f64;
    }
    extern "C" {
        pub fn exp(_X: f64) -> f64;
    }
    extern "C" {
        pub fn log(_X: f64) -> f64;
    }
    extern "C" {
        pub fn log10(_X: f64) -> f64;
    }
    extern "C" {
        pub fn pow(_X: f64, _Y: f64) -> f64;
    }
    extern "C" {
        pub fn sqrt(_X: f64) -> f64;
    }
    extern "C" {
        pub fn ceil(_X: f64) -> f64;
    }
    extern "C" {
        pub fn floor(_X: f64) -> f64;
    }
    extern "C" {
        pub fn fabsf(x: f32) -> f32;
    }
    extern "C" {
        pub fn fabsl(arg1: u128) -> u128;
    }
    extern "C" {
        pub fn fabs(_X: f64) -> f64;
    }
    extern "C" {
        pub fn ldexp(_X: f64, _Y: ::std::os::raw::c_int) -> f64;
    }
    extern "C" {
        pub fn frexp(_X: f64, _Y: *mut ::std::os::raw::c_int) -> f64;
    }
    extern "C" {
        pub fn modf(_X: f64, _Y: *mut f64) -> f64;
    }
    extern "C" {
        pub fn fmod(_X: f64, _Y: f64) -> f64;
    }
    extern "C" {
        pub fn sincos(__x: f64, p_sin: *mut f64, p_cos: *mut f64);
    }
    extern "C" {
        pub fn sincosl(__x: u128, p_sin: *mut u128, p_cos: *mut u128);
    }
    extern "C" {
        pub fn sincosf(__x: f32, p_sin: *mut f32, p_cos: *mut f32);
    }
    extern "C" {
        pub fn abs(_X: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn labs(_X: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
    }
    extern "C" {
        pub fn atof(_String: *const ::std::os::raw::c_char) -> f64;
    }
    extern "C" {
        pub fn _atof_l(_String: *const ::std::os::raw::c_char, _Locale: root::_locale_t) -> f64;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _complex {
        pub x: f64,
        pub y: f64,
    }
    #[test]
    fn bindgen_test_layout__complex() {
        const UNINIT: ::std::mem::MaybeUninit<_complex> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<_complex>(),
            16usize,
            concat!("Size of: ", stringify!(_complex))
        );
        assert_eq!(
            ::std::mem::align_of::<_complex>(),
            8usize,
            concat!("Alignment of ", stringify!(_complex))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_complex),
                "::",
                stringify!(x)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_complex),
                "::",
                stringify!(y)
            )
        );
    }
    extern "C" {
        pub fn _cabs(_ComplexA: root::_complex) -> f64;
    }
    extern "C" {
        pub fn _hypot(_X: f64, _Y: f64) -> f64;
    }
    extern "C" {
        pub fn _j0(_X: f64) -> f64;
    }
    extern "C" {
        pub fn _j1(_X: f64) -> f64;
    }
    extern "C" {
        pub fn _jn(_X: ::std::os::raw::c_int, _Y: f64) -> f64;
    }
    extern "C" {
        pub fn _y0(_X: f64) -> f64;
    }
    extern "C" {
        pub fn _y1(_X: f64) -> f64;
    }
    extern "C" {
        pub fn _yn(_X: ::std::os::raw::c_int, _Y: f64) -> f64;
    }
    extern "C" {
        pub fn _matherr(arg1: *mut root::_exception) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _chgsign(_X: f64) -> f64;
    }
    extern "C" {
        pub fn _copysign(_Number: f64, _Sign: f64) -> f64;
    }
    extern "C" {
        pub fn _logb(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn _nextafter(arg1: f64, arg2: f64) -> f64;
    }
    extern "C" {
        pub fn _scalb(arg1: f64, arg2: ::std::os::raw::c_long) -> f64;
    }
    extern "C" {
        pub fn _finite(arg1: f64) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _fpclass(arg1: f64) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _isnan(arg1: f64) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn j0(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn j1(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
    }
    extern "C" {
        pub fn y0(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn y1(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
    }
    extern "C" {
        pub fn chgsign(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn finite(arg1: f64) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn fpclass(arg1: f64) -> ::std::os::raw::c_int;
    }
    pub type float_t = f32;
    pub type double_t = f64;
    extern "C" {
        pub fn __fpclassifyl(arg1: u128) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn __fpclassifyf(arg1: f32) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn __fpclassify(arg1: f64) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn __isnan(arg1: f64) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn __isnanf(arg1: f32) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn __isnanl(arg1: u128) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn __signbit(arg1: f64) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn __signbitf(arg1: f32) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn __signbitl(arg1: u128) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn sinf(_X: f32) -> f32;
    }
    extern "C" {
        pub fn sinl(arg1: u128) -> u128;
    }
    extern "C" {
        pub fn cosf(_X: f32) -> f32;
    }
    extern "C" {
        pub fn cosl(arg1: u128) -> u128;
    }
    extern "C" {
        pub fn tanf(_X: f32) -> f32;
    }
    extern "C" {
        pub fn tanl(arg1: u128) -> u128;
    }
    extern "C" {
        pub fn asinf(_X: f32) -> f32;
    }
    extern "C" {
        pub fn asinl(arg1: u128) -> u128;
    }
    extern "C" {
        pub fn acosf(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn acosl(arg1: u128) -> u128;
    }
    extern "C" {
        pub fn atanf(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn atanl(arg1: u128) -> u128;
    }
    extern "C" {
        pub fn atan2f(arg1: f32, arg2: f32) -> f32;
    }
    extern "C" {
        pub fn atan2l(arg1: u128, arg2: u128) -> u128;
    }
    extern "C" {
        pub fn sinhf(_X: f32) -> f32;
    }
    extern "C" {
        pub fn sinhl(arg1: u128) -> u128;
    }
    extern "C" {
        pub fn coshf(_X: f32) -> f32;
    }
    extern "C" {
        pub fn coshl(arg1: u128) -> u128;
    }
    extern "C" {
        pub fn tanhf(_X: f32) -> f32;
    }
    extern "C" {
        pub fn tanhl(arg1: u128) -> u128;
    }
    extern "C" {
        pub fn acosh(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn acoshf(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn acoshl(arg1: u128) -> u128;
    }
    extern "C" {
        pub fn asinh(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn asinhf(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn asinhl(arg1: u128) -> u128;
    }
    extern "C" {
        pub fn atanh(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn atanhf(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn atanhl(arg1: u128) -> u128;
    }
    extern "C" {
        pub fn expf(_X: f32) -> f32;
    }
    extern "C" {
        pub fn expl(arg1: u128) -> u128;
    }
    extern "C" {
        pub fn exp2(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn exp2f(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn exp2l(arg1: u128) -> u128;
    }
    extern "C" {
        pub fn expm1(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn expm1f(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn expm1l(arg1: u128) -> u128;
    }
    extern "C" {
        pub fn frexpf(_X: f32, _Y: *mut ::std::os::raw::c_int) -> f32;
    }
    extern "C" {
        pub fn frexpl(arg1: u128, arg2: *mut ::std::os::raw::c_int) -> u128;
    }
    extern "C" {
        pub fn ilogb(arg1: f64) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn ilogbf(arg1: f32) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn ilogbl(arg1: u128) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn ldexpf(_X: f32, _Y: ::std::os::raw::c_int) -> f32;
    }
    extern "C" {
        pub fn ldexpl(arg1: u128, arg2: ::std::os::raw::c_int) -> u128;
    }
    extern "C" {
        pub fn logf(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn logl(arg1: u128) -> u128;
    }
    extern "C" {
        pub fn log10f(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn log10l(arg1: u128) -> u128;
    }
    extern "C" {
        pub fn log1p(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn log1pf(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn log1pl(arg1: u128) -> u128;
    }
    extern "C" {
        pub fn log2(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn log2f(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn log2l(arg1: u128) -> u128;
    }
    extern "C" {
        pub fn logb(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn logbf(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn logbl(arg1: u128) -> u128;
    }
    extern "C" {
        pub fn modff(arg1: f32, arg2: *mut f32) -> f32;
    }
    extern "C" {
        pub fn modfl(arg1: u128, arg2: *mut u128) -> u128;
    }
    extern "C" {
        pub fn scalbn(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
    }
    extern "C" {
        pub fn scalbnf(arg1: f32, arg2: ::std::os::raw::c_int) -> f32;
    }
    extern "C" {
        pub fn scalbnl(arg1: u128, arg2: ::std::os::raw::c_int) -> u128;
    }
    extern "C" {
        pub fn scalbln(arg1: f64, arg2: ::std::os::raw::c_long) -> f64;
    }
    extern "C" {
        pub fn scalblnf(arg1: f32, arg2: ::std::os::raw::c_long) -> f32;
    }
    extern "C" {
        pub fn scalblnl(arg1: u128, arg2: ::std::os::raw::c_long) -> u128;
    }
    extern "C" {
        pub fn cbrt(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn cbrtf(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn cbrtl(arg1: u128) -> u128;
    }
    extern "C" {
        pub fn hypot(arg1: f64, arg2: f64) -> f64;
    }
    extern "C" {
        pub fn hypotf(x: f32, y: f32) -> f32;
    }
    extern "C" {
        pub fn hypotl(arg1: u128, arg2: u128) -> u128;
    }
    extern "C" {
        pub fn powf(_X: f32, _Y: f32) -> f32;
    }
    extern "C" {
        pub fn powl(arg1: u128, arg2: u128) -> u128;
    }
    extern "C" {
        pub fn sqrtf(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn sqrtl(arg1: u128) -> u128;
    }
    extern "C" {
        pub fn erf(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn erff(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn erfl(arg1: u128) -> u128;
    }
    extern "C" {
        pub fn erfc(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn erfcf(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn erfcl(arg1: u128) -> u128;
    }
    extern "C" {
        pub fn lgamma(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn lgammaf(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn lgammal(arg1: u128) -> u128;
    }
    extern "C" {
        pub static mut signgam: ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn tgamma(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn tgammaf(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn tgammal(arg1: u128) -> u128;
    }
    extern "C" {
        pub fn ceilf(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn ceill(arg1: u128) -> u128;
    }
    extern "C" {
        pub fn floorf(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn floorl(arg1: u128) -> u128;
    }
    extern "C" {
        pub fn nearbyint(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn nearbyintf(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn nearbyintl(arg1: u128) -> u128;
    }
    extern "C" {
        pub fn rint(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn rintf(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn rintl(arg1: u128) -> u128;
    }
    extern "C" {
        pub fn lrint(arg1: f64) -> ::std::os::raw::c_long;
    }
    extern "C" {
        pub fn lrintf(arg1: f32) -> ::std::os::raw::c_long;
    }
    extern "C" {
        pub fn lrintl(arg1: u128) -> ::std::os::raw::c_long;
    }
    extern "C" {
        pub fn llrint(arg1: f64) -> ::std::os::raw::c_longlong;
    }
    extern "C" {
        pub fn llrintf(arg1: f32) -> ::std::os::raw::c_longlong;
    }
    extern "C" {
        pub fn llrintl(arg1: u128) -> ::std::os::raw::c_longlong;
    }
    extern "C" {
        pub fn round(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn roundf(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn roundl(arg1: u128) -> u128;
    }
    extern "C" {
        pub fn lround(arg1: f64) -> ::std::os::raw::c_long;
    }
    extern "C" {
        pub fn lroundf(arg1: f32) -> ::std::os::raw::c_long;
    }
    extern "C" {
        pub fn lroundl(arg1: u128) -> ::std::os::raw::c_long;
    }
    extern "C" {
        pub fn llround(arg1: f64) -> ::std::os::raw::c_longlong;
    }
    extern "C" {
        pub fn llroundf(arg1: f32) -> ::std::os::raw::c_longlong;
    }
    extern "C" {
        pub fn llroundl(arg1: u128) -> ::std::os::raw::c_longlong;
    }
    extern "C" {
        pub fn trunc(arg1: f64) -> f64;
    }
    extern "C" {
        pub fn truncf(arg1: f32) -> f32;
    }
    extern "C" {
        pub fn truncl(arg1: u128) -> u128;
    }
    extern "C" {
        pub fn fmodf(arg1: f32, arg2: f32) -> f32;
    }
    extern "C" {
        pub fn fmodl(arg1: u128, arg2: u128) -> u128;
    }
    extern "C" {
        pub fn remainder(arg1: f64, arg2: f64) -> f64;
    }
    extern "C" {
        pub fn remainderf(arg1: f32, arg2: f32) -> f32;
    }
    extern "C" {
        pub fn remainderl(arg1: u128, arg2: u128) -> u128;
    }
    extern "C" {
        pub fn remquo(arg1: f64, arg2: f64, arg3: *mut ::std::os::raw::c_int) -> f64;
    }
    extern "C" {
        pub fn remquof(arg1: f32, arg2: f32, arg3: *mut ::std::os::raw::c_int) -> f32;
    }
    extern "C" {
        pub fn remquol(arg1: u128, arg2: u128, arg3: *mut ::std::os::raw::c_int) -> u128;
    }
    extern "C" {
        pub fn copysign(arg1: f64, arg2: f64) -> f64;
    }
    extern "C" {
        pub fn copysignf(arg1: f32, arg2: f32) -> f32;
    }
    extern "C" {
        pub fn copysignl(arg1: u128, arg2: u128) -> u128;
    }
    extern "C" {
        pub fn nan(tagp: *const ::std::os::raw::c_char) -> f64;
    }
    extern "C" {
        pub fn nanf(tagp: *const ::std::os::raw::c_char) -> f32;
    }
    extern "C" {
        pub fn nanl(tagp: *const ::std::os::raw::c_char) -> u128;
    }
    extern "C" {
        pub fn nextafter(arg1: f64, arg2: f64) -> f64;
    }
    extern "C" {
        pub fn nextafterf(arg1: f32, arg2: f32) -> f32;
    }
    extern "C" {
        pub fn nextafterl(arg1: u128, arg2: u128) -> u128;
    }
    extern "C" {
        pub fn nexttoward(arg1: f64, arg2: u128) -> f64;
    }
    extern "C" {
        pub fn nexttowardf(arg1: f32, arg2: u128) -> f32;
    }
    extern "C" {
        pub fn nexttowardl(arg1: u128, arg2: u128) -> u128;
    }
    extern "C" {
        pub fn fdim(x: f64, y: f64) -> f64;
    }
    extern "C" {
        pub fn fdimf(x: f32, y: f32) -> f32;
    }
    extern "C" {
        pub fn fdiml(x: u128, y: u128) -> u128;
    }
    extern "C" {
        pub fn fmax(arg1: f64, arg2: f64) -> f64;
    }
    extern "C" {
        pub fn fmaxf(arg1: f32, arg2: f32) -> f32;
    }
    extern "C" {
        pub fn fmaxl(arg1: u128, arg2: u128) -> u128;
    }
    extern "C" {
        pub fn fmin(arg1: f64, arg2: f64) -> f64;
    }
    extern "C" {
        pub fn fminf(arg1: f32, arg2: f32) -> f32;
    }
    extern "C" {
        pub fn fminl(arg1: u128, arg2: u128) -> u128;
    }
    extern "C" {
        pub fn fma(arg1: f64, arg2: f64, arg3: f64) -> f64;
    }
    extern "C" {
        pub fn fmaf(arg1: f32, arg2: f32, arg3: f32) -> f32;
    }
    extern "C" {
        pub fn fmal(arg1: u128, arg2: u128, arg3: u128) -> u128;
    }
    extern "C" {
        pub fn _copysignf(_Number: f32, _Sign: f32) -> f32;
    }
    extern "C" {
        pub fn _chgsignf(_X: f32) -> f32;
    }
    extern "C" {
        pub fn _logbf(_X: f32) -> f32;
    }
    extern "C" {
        pub fn _nextafterf(_X: f32, _Y: f32) -> f32;
    }
    extern "C" {
        pub fn _finitef(_X: f32) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _isnanf(_X: f32) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _fpclassf(_X: f32) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _chgsignl(arg1: u128) -> u128;
    }
    extern "C" {
        pub fn _itow_s(
            _Val: ::std::os::raw::c_int,
            _DstBuf: *mut u16,
            _SizeInWords: usize,
            _Radix: ::std::os::raw::c_int,
        ) -> root::errno_t;
    }
    extern "C" {
        pub fn _ltow_s(
            _Val: ::std::os::raw::c_long,
            _DstBuf: *mut u16,
            _SizeInWords: usize,
            _Radix: ::std::os::raw::c_int,
        ) -> root::errno_t;
    }
    extern "C" {
        pub fn _ultow_s(
            _Val: ::std::os::raw::c_ulong,
            _DstBuf: *mut u16,
            _SizeInWords: usize,
            _Radix: ::std::os::raw::c_int,
        ) -> root::errno_t;
    }
    extern "C" {
        pub fn _wgetenv_s(
            _ReturnSize: *mut usize,
            _DstBuf: *mut u16,
            _DstSizeInWords: usize,
            _VarName: *const u16,
        ) -> root::errno_t;
    }
    extern "C" {
        pub fn _wdupenv_s(
            _Buffer: *mut *mut u16,
            _BufferSizeInWords: *mut usize,
            _VarName: *const u16,
        ) -> root::errno_t;
    }
    extern "C" {
        pub fn _i64tow_s(
            _Val: ::std::os::raw::c_longlong,
            _DstBuf: *mut u16,
            _SizeInWords: usize,
            _Radix: ::std::os::raw::c_int,
        ) -> root::errno_t;
    }
    extern "C" {
        pub fn _ui64tow_s(
            _Val: ::std::os::raw::c_ulonglong,
            _DstBuf: *mut u16,
            _SizeInWords: usize,
            _Radix: ::std::os::raw::c_int,
        ) -> root::errno_t;
    }
    extern "C" {
        pub fn _wmakepath_s(
            _PathResult: *mut u16,
            _SizeInWords: usize,
            _Drive: *const u16,
            _Dir: *const u16,
            _Filename: *const u16,
            _Ext: *const u16,
        ) -> root::errno_t;
    }
    extern "C" {
        pub fn _wputenv_s(_Name: *const u16, _Value: *const u16) -> root::errno_t;
    }
    extern "C" {
        pub fn _wsearchenv_s(
            _Filename: *const u16,
            _EnvVar: *const u16,
            _ResultPath: *mut u16,
            _SizeInWords: usize,
        ) -> root::errno_t;
    }
    extern "C" {
        pub fn _wsplitpath_s(
            _FullPath: *const u16,
            _Drive: *mut u16,
            _DriveSizeInWords: usize,
            _Dir: *mut u16,
            _DirSizeInWords: usize,
            _Filename: *mut u16,
            _FilenameSizeInWords: usize,
            _Ext: *mut u16,
            _ExtSizeInWords: usize,
        ) -> root::errno_t;
    }
    pub type _onexit_t = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _div_t {
        pub quot: ::std::os::raw::c_int,
        pub rem: ::std::os::raw::c_int,
    }
    #[test]
    fn bindgen_test_layout__div_t() {
        const UNINIT: ::std::mem::MaybeUninit<_div_t> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<_div_t>(),
            8usize,
            concat!("Size of: ", stringify!(_div_t))
        );
        assert_eq!(
            ::std::mem::align_of::<_div_t>(),
            4usize,
            concat!("Alignment of ", stringify!(_div_t))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_div_t),
                "::",
                stringify!(quot)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_div_t),
                "::",
                stringify!(rem)
            )
        );
    }
    pub type div_t = root::_div_t;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _ldiv_t {
        pub quot: ::std::os::raw::c_long,
        pub rem: ::std::os::raw::c_long,
    }
    #[test]
    fn bindgen_test_layout__ldiv_t() {
        const UNINIT: ::std::mem::MaybeUninit<_ldiv_t> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<_ldiv_t>(),
            8usize,
            concat!("Size of: ", stringify!(_ldiv_t))
        );
        assert_eq!(
            ::std::mem::align_of::<_ldiv_t>(),
            4usize,
            concat!("Alignment of ", stringify!(_ldiv_t))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_ldiv_t),
                "::",
                stringify!(quot)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_ldiv_t),
                "::",
                stringify!(rem)
            )
        );
    }
    pub type ldiv_t = root::_ldiv_t;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _LDOUBLE {
        pub ld: [::std::os::raw::c_uchar; 10usize],
    }
    #[test]
    fn bindgen_test_layout__LDOUBLE() {
        const UNINIT: ::std::mem::MaybeUninit<_LDOUBLE> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<_LDOUBLE>(),
            10usize,
            concat!("Size of: ", stringify!(_LDOUBLE))
        );
        assert_eq!(
            ::std::mem::align_of::<_LDOUBLE>(),
            1usize,
            concat!("Alignment of ", stringify!(_LDOUBLE))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).ld) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LDOUBLE),
                "::",
                stringify!(ld)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _CRT_DOUBLE {
        pub x: f64,
    }
    #[test]
    fn bindgen_test_layout__CRT_DOUBLE() {
        const UNINIT: ::std::mem::MaybeUninit<_CRT_DOUBLE> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<_CRT_DOUBLE>(),
            8usize,
            concat!("Size of: ", stringify!(_CRT_DOUBLE))
        );
        assert_eq!(
            ::std::mem::align_of::<_CRT_DOUBLE>(),
            8usize,
            concat!("Alignment of ", stringify!(_CRT_DOUBLE))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_CRT_DOUBLE),
                "::",
                stringify!(x)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _CRT_FLOAT {
        pub f: f32,
    }
    #[test]
    fn bindgen_test_layout__CRT_FLOAT() {
        const UNINIT: ::std::mem::MaybeUninit<_CRT_FLOAT> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<_CRT_FLOAT>(),
            4usize,
            concat!("Size of: ", stringify!(_CRT_FLOAT))
        );
        assert_eq!(
            ::std::mem::align_of::<_CRT_FLOAT>(),
            4usize,
            concat!("Alignment of ", stringify!(_CRT_FLOAT))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).f) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_CRT_FLOAT),
                "::",
                stringify!(f)
            )
        );
    }
    #[repr(C)]
    #[repr(align(16))]
    #[derive(Debug, Copy, Clone)]
    pub struct _LONGDOUBLE {
        pub x: u128,
    }
    #[test]
    fn bindgen_test_layout__LONGDOUBLE() {
        const UNINIT: ::std::mem::MaybeUninit<_LONGDOUBLE> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<_LONGDOUBLE>(),
            16usize,
            concat!("Size of: ", stringify!(_LONGDOUBLE))
        );
        assert_eq!(
            ::std::mem::align_of::<_LONGDOUBLE>(),
            16usize,
            concat!("Alignment of ", stringify!(_LONGDOUBLE))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LONGDOUBLE),
                "::",
                stringify!(x)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _LDBL12 {
        pub ld12: [::std::os::raw::c_uchar; 12usize],
    }
    #[test]
    fn bindgen_test_layout__LDBL12() {
        const UNINIT: ::std::mem::MaybeUninit<_LDBL12> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<_LDBL12>(),
            12usize,
            concat!("Size of: ", stringify!(_LDBL12))
        );
        assert_eq!(
            ::std::mem::align_of::<_LDBL12>(),
            1usize,
            concat!("Alignment of ", stringify!(_LDBL12))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).ld12) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LDBL12),
                "::",
                stringify!(ld12)
            )
        );
    }
    extern "C" {
        pub fn ___mb_cur_max_func() -> ::std::os::raw::c_int;
    }
    pub type _purecall_handler = ::std::option::Option<unsafe extern "C" fn()>;
    extern "C" {
        pub fn _set_purecall_handler(_Handler: root::_purecall_handler) -> root::_purecall_handler;
    }
    extern "C" {
        pub fn _get_purecall_handler() -> root::_purecall_handler;
    }
    pub type _invalid_parameter_handler = ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const u16,
            arg2: *const u16,
            arg3: *const u16,
            arg4: ::std::os::raw::c_uint,
            arg5: usize,
        ),
    >;
    extern "C" {
        pub fn _set_invalid_parameter_handler(
            _Handler: root::_invalid_parameter_handler,
        ) -> root::_invalid_parameter_handler;
    }
    extern "C" {
        pub fn _get_invalid_parameter_handler() -> root::_invalid_parameter_handler;
    }
    extern "C" {
        pub fn _errno() -> *mut ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _set_errno(_Value: ::std::os::raw::c_int) -> root::errno_t;
    }
    extern "C" {
        pub fn _get_errno(_Value: *mut ::std::os::raw::c_int) -> root::errno_t;
    }
    extern "C" {
        pub fn __doserrno() -> *mut ::std::os::raw::c_ulong;
    }
    extern "C" {
        pub fn _set_doserrno(_Value: ::std::os::raw::c_ulong) -> root::errno_t;
    }
    extern "C" {
        pub fn _get_doserrno(_Value: *mut ::std::os::raw::c_ulong) -> root::errno_t;
    }
    extern "C" {
        pub fn __sys_errlist() -> *mut *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn __sys_nerr() -> *mut ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn __p___argv() -> *mut *mut *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn __p__fmode() -> *mut ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn __p___argc() -> *mut ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn __p___wargv() -> *mut *mut *mut u16;
    }
    extern "C" {
        pub fn __p__environ() -> *mut *mut *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn __p__wenviron() -> *mut *mut *mut u16;
    }
    extern "C" {
        pub fn __p__pgmptr() -> *mut *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn __p__wpgmptr() -> *mut *mut u16;
    }
    extern "C" {
        pub fn _get_pgmptr(_Value: *mut *mut ::std::os::raw::c_char) -> root::errno_t;
    }
    extern "C" {
        pub fn _get_wpgmptr(_Value: *mut *mut u16) -> root::errno_t;
    }
    extern "C" {
        pub fn _set_fmode(_Mode: ::std::os::raw::c_int) -> root::errno_t;
    }
    extern "C" {
        pub fn _get_fmode(_PMode: *mut ::std::os::raw::c_int) -> root::errno_t;
    }
    extern "C" {
        pub fn _get_osplatform(_Value: *mut ::std::os::raw::c_uint) -> root::errno_t;
    }
    extern "C" {
        pub fn _get_osver(_Value: *mut ::std::os::raw::c_uint) -> root::errno_t;
    }
    extern "C" {
        pub fn _get_winver(_Value: *mut ::std::os::raw::c_uint) -> root::errno_t;
    }
    extern "C" {
        pub fn _get_winmajor(_Value: *mut ::std::os::raw::c_uint) -> root::errno_t;
    }
    extern "C" {
        pub fn _get_winminor(_Value: *mut ::std::os::raw::c_uint) -> root::errno_t;
    }
    extern "C" {
        pub fn exit(_Code: ::std::os::raw::c_int) -> !;
    }
    extern "C" {
        pub fn _exit(_Code: ::std::os::raw::c_int) -> !;
    }
    extern "C" {
        pub fn quick_exit(_Code: ::std::os::raw::c_int) -> !;
    }
    extern "C" {
        pub fn _Exit(arg1: ::std::os::raw::c_int) -> !;
    }
    extern "C" {
        pub fn abort() -> !;
    }
    extern "C" {
        pub fn _set_abort_behavior(
            _Flags: ::std::os::raw::c_uint,
            _Mask: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_uint;
    }
    extern "C" {
        pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>)
            -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn at_quick_exit(
            arg1: ::std::option::Option<unsafe extern "C" fn()>,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn atoi(_Str: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _atoi_l(
            _Str: *const ::std::os::raw::c_char,
            _Locale: root::_locale_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn atol(_Str: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
    }
    extern "C" {
        pub fn _atol_l(
            _Str: *const ::std::os::raw::c_char,
            _Locale: root::_locale_t,
        ) -> ::std::os::raw::c_long;
    }
    extern "C" {
        pub fn bsearch(
            _Key: *const ::std::os::raw::c_void,
            _Base: *const ::std::os::raw::c_void,
            _NumOfElements: usize,
            _SizeOfElements: usize,
            _PtFuncCompare: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *const ::std::os::raw::c_void,
                    arg2: *const ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_int,
            >,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        pub fn qsort(
            _Base: *mut ::std::os::raw::c_void,
            _NumOfElements: usize,
            _SizeOfElements: usize,
            _PtFuncCompare: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *const ::std::os::raw::c_void,
                    arg2: *const ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_int,
            >,
        );
    }
    extern "C" {
        pub fn _byteswap_ushort(_Short: ::std::os::raw::c_ushort) -> ::std::os::raw::c_ushort;
    }
    extern "C" {
        pub fn _byteswap_ulong(_Long: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        pub fn _byteswap_uint64(_Int64: ::std::os::raw::c_ulonglong)
            -> ::std::os::raw::c_ulonglong;
    }
    extern "C" {
        pub fn div(
            _Numerator: ::std::os::raw::c_int,
            _Denominator: ::std::os::raw::c_int,
        ) -> root::div_t;
    }
    extern "C" {
        pub fn getenv(_VarName: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn _itoa(
            _Value: ::std::os::raw::c_int,
            _Dest: *mut ::std::os::raw::c_char,
            _Radix: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn _i64toa(
            _Val: ::std::os::raw::c_longlong,
            _DstBuf: *mut ::std::os::raw::c_char,
            _Radix: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn _ui64toa(
            _Val: ::std::os::raw::c_ulonglong,
            _DstBuf: *mut ::std::os::raw::c_char,
            _Radix: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn _atoi64(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
    }
    extern "C" {
        pub fn _atoi64_l(
            _String: *const ::std::os::raw::c_char,
            _Locale: root::_locale_t,
        ) -> ::std::os::raw::c_longlong;
    }
    extern "C" {
        pub fn _strtoi64(
            _String: *const ::std::os::raw::c_char,
            _EndPtr: *mut *mut ::std::os::raw::c_char,
            _Radix: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_longlong;
    }
    extern "C" {
        pub fn _strtoi64_l(
            _String: *const ::std::os::raw::c_char,
            _EndPtr: *mut *mut ::std::os::raw::c_char,
            _Radix: ::std::os::raw::c_int,
            _Locale: root::_locale_t,
        ) -> ::std::os::raw::c_longlong;
    }
    extern "C" {
        pub fn _strtoui64(
            _String: *const ::std::os::raw::c_char,
            _EndPtr: *mut *mut ::std::os::raw::c_char,
            _Radix: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_ulonglong;
    }
    extern "C" {
        pub fn _strtoui64_l(
            _String: *const ::std::os::raw::c_char,
            _EndPtr: *mut *mut ::std::os::raw::c_char,
            _Radix: ::std::os::raw::c_int,
            _Locale: root::_locale_t,
        ) -> ::std::os::raw::c_ulonglong;
    }
    extern "C" {
        pub fn ldiv(
            _Numerator: ::std::os::raw::c_long,
            _Denominator: ::std::os::raw::c_long,
        ) -> root::ldiv_t;
    }
    extern "C" {
        pub fn _ltoa(
            _Value: ::std::os::raw::c_long,
            _Dest: *mut ::std::os::raw::c_char,
            _Radix: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn mblen(_Ch: *const ::std::os::raw::c_char, _MaxCount: usize)
            -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _mblen_l(
            _Ch: *const ::std::os::raw::c_char,
            _MaxCount: usize,
            _Locale: root::_locale_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _mbstrlen(_Str: *const ::std::os::raw::c_char) -> usize;
    }
    extern "C" {
        pub fn _mbstrlen_l(_Str: *const ::std::os::raw::c_char, _Locale: root::_locale_t) -> usize;
    }
    extern "C" {
        pub fn _mbstrnlen(_Str: *const ::std::os::raw::c_char, _MaxCount: usize) -> usize;
    }
    extern "C" {
        pub fn _mbstrnlen_l(
            _Str: *const ::std::os::raw::c_char,
            _MaxCount: usize,
            _Locale: root::_locale_t,
        ) -> usize;
    }
    extern "C" {
        pub fn mbtowc(
            _DstCh: *mut u16,
            _SrcCh: *const ::std::os::raw::c_char,
            _SrcSizeInBytes: usize,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _mbtowc_l(
            _DstCh: *mut u16,
            _SrcCh: *const ::std::os::raw::c_char,
            _SrcSizeInBytes: usize,
            _Locale: root::_locale_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn mbstowcs(
            _Dest: *mut u16,
            _Source: *const ::std::os::raw::c_char,
            _MaxCount: usize,
        ) -> usize;
    }
    extern "C" {
        pub fn _mbstowcs_l(
            _Dest: *mut u16,
            _Source: *const ::std::os::raw::c_char,
            _MaxCount: usize,
            _Locale: root::_locale_t,
        ) -> usize;
    }
    extern "C" {
        pub fn mkstemp(template_name: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn rand() -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _set_error_mode(_Mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn srand(_Seed: ::std::os::raw::c_uint);
    }
    extern "C" {
        pub fn strtold(
            arg1: *const ::std::os::raw::c_char,
            arg2: *mut *mut ::std::os::raw::c_char,
        ) -> u128;
    }
    extern "C" {
        pub fn __strtod(
            arg1: *const ::std::os::raw::c_char,
            arg2: *mut *mut ::std::os::raw::c_char,
        ) -> f64;
    }
    extern "C" {
        pub fn _strtof_l(
            _Str: *const ::std::os::raw::c_char,
            _EndPtr: *mut *mut ::std::os::raw::c_char,
            _Locale: root::_locale_t,
        ) -> f32;
    }
    extern "C" {
        pub fn _strtod_l(
            _Str: *const ::std::os::raw::c_char,
            _EndPtr: *mut *mut ::std::os::raw::c_char,
            _Locale: root::_locale_t,
        ) -> f64;
    }
    extern "C" {
        pub fn strtol(
            _Str: *const ::std::os::raw::c_char,
            _EndPtr: *mut *mut ::std::os::raw::c_char,
            _Radix: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_long;
    }
    extern "C" {
        pub fn _strtol_l(
            _Str: *const ::std::os::raw::c_char,
            _EndPtr: *mut *mut ::std::os::raw::c_char,
            _Radix: ::std::os::raw::c_int,
            _Locale: root::_locale_t,
        ) -> ::std::os::raw::c_long;
    }
    extern "C" {
        pub fn strtoul(
            _Str: *const ::std::os::raw::c_char,
            _EndPtr: *mut *mut ::std::os::raw::c_char,
            _Radix: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        pub fn _strtoul_l(
            _Str: *const ::std::os::raw::c_char,
            _EndPtr: *mut *mut ::std::os::raw::c_char,
            _Radix: ::std::os::raw::c_int,
            _Locale: root::_locale_t,
        ) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        pub fn system(_Command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _ultoa(
            _Value: ::std::os::raw::c_ulong,
            _Dest: *mut ::std::os::raw::c_char,
            _Radix: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn wctomb(_MbCh: *mut ::std::os::raw::c_char, _WCh: u16) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _wctomb_l(
            _MbCh: *mut ::std::os::raw::c_char,
            _WCh: u16,
            _Locale: root::_locale_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn wcstombs(
            _Dest: *mut ::std::os::raw::c_char,
            _Source: *const u16,
            _MaxCount: usize,
        ) -> usize;
    }
    extern "C" {
        pub fn _wcstombs_l(
            _Dest: *mut ::std::os::raw::c_char,
            _Source: *const u16,
            _MaxCount: usize,
            _Locale: root::_locale_t,
        ) -> usize;
    }
    extern "C" {
        pub fn calloc(_NumOfElements: usize, _SizeOfElements: usize)
            -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        pub fn free(_Memory: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        pub fn malloc(_Size: usize) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        pub fn realloc(
            _Memory: *mut ::std::os::raw::c_void,
            _NewSize: usize,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        pub fn _aligned_free(_Memory: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        pub fn _aligned_malloc(_Size: usize, _Alignment: usize) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        pub fn _aligned_offset_malloc(
            _Size: usize,
            _Alignment: usize,
            _Offset: usize,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        pub fn _aligned_realloc(
            _Memory: *mut ::std::os::raw::c_void,
            _Size: usize,
            _Alignment: usize,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        pub fn _aligned_offset_realloc(
            _Memory: *mut ::std::os::raw::c_void,
            _Size: usize,
            _Alignment: usize,
            _Offset: usize,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        pub fn _recalloc(
            _Memory: *mut ::std::os::raw::c_void,
            _Count: usize,
            _Size: usize,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        pub fn _aligned_recalloc(
            _Memory: *mut ::std::os::raw::c_void,
            _Count: usize,
            _Size: usize,
            _Alignment: usize,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        pub fn _aligned_offset_recalloc(
            _Memory: *mut ::std::os::raw::c_void,
            _Count: usize,
            _Size: usize,
            _Alignment: usize,
            _Offset: usize,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        pub fn _aligned_msize(
            _Memory: *mut ::std::os::raw::c_void,
            _Alignment: usize,
            _Offset: usize,
        ) -> usize;
    }
    extern "C" {
        pub fn _itow(
            _Value: ::std::os::raw::c_int,
            _Dest: *mut u16,
            _Radix: ::std::os::raw::c_int,
        ) -> *mut u16;
    }
    extern "C" {
        pub fn _ltow(
            _Value: ::std::os::raw::c_long,
            _Dest: *mut u16,
            _Radix: ::std::os::raw::c_int,
        ) -> *mut u16;
    }
    extern "C" {
        pub fn _ultow(
            _Value: ::std::os::raw::c_ulong,
            _Dest: *mut u16,
            _Radix: ::std::os::raw::c_int,
        ) -> *mut u16;
    }
    extern "C" {
        pub fn wcstod(_Str: *const u16, _EndPtr: *mut *mut u16) -> f64;
    }
    extern "C" {
        pub fn wcstof(nptr: *const u16, endptr: *mut *mut u16) -> f32;
    }
    extern "C" {
        pub fn wcstold(arg1: *const u16, arg2: *mut *mut u16) -> u128;
    }
    extern "C" {
        pub fn _wcstod_l(_Str: *const u16, _EndPtr: *mut *mut u16, _Locale: root::_locale_t)
            -> f64;
    }
    extern "C" {
        pub fn _wcstof_l(_Str: *const u16, _EndPtr: *mut *mut u16, _Locale: root::_locale_t)
            -> f32;
    }
    extern "C" {
        pub fn wcstol(
            _Str: *const u16,
            _EndPtr: *mut *mut u16,
            _Radix: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_long;
    }
    extern "C" {
        pub fn _wcstol_l(
            _Str: *const u16,
            _EndPtr: *mut *mut u16,
            _Radix: ::std::os::raw::c_int,
            _Locale: root::_locale_t,
        ) -> ::std::os::raw::c_long;
    }
    extern "C" {
        pub fn wcstoul(
            _Str: *const u16,
            _EndPtr: *mut *mut u16,
            _Radix: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        pub fn _wcstoul_l(
            _Str: *const u16,
            _EndPtr: *mut *mut u16,
            _Radix: ::std::os::raw::c_int,
            _Locale: root::_locale_t,
        ) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        pub fn _wgetenv(_VarName: *const u16) -> *mut u16;
    }
    extern "C" {
        pub fn _wsystem(_Command: *const u16) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _wtof(_Str: *const u16) -> f64;
    }
    extern "C" {
        pub fn _wtof_l(_Str: *const u16, _Locale: root::_locale_t) -> f64;
    }
    extern "C" {
        pub fn _wtoi(_Str: *const u16) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _wtoi_l(_Str: *const u16, _Locale: root::_locale_t) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _wtol(_Str: *const u16) -> ::std::os::raw::c_long;
    }
    extern "C" {
        pub fn _wtol_l(_Str: *const u16, _Locale: root::_locale_t) -> ::std::os::raw::c_long;
    }
    extern "C" {
        pub fn _i64tow(
            _Val: ::std::os::raw::c_longlong,
            _DstBuf: *mut u16,
            _Radix: ::std::os::raw::c_int,
        ) -> *mut u16;
    }
    extern "C" {
        pub fn _ui64tow(
            _Val: ::std::os::raw::c_ulonglong,
            _DstBuf: *mut u16,
            _Radix: ::std::os::raw::c_int,
        ) -> *mut u16;
    }
    extern "C" {
        pub fn _wtoi64(_Str: *const u16) -> ::std::os::raw::c_longlong;
    }
    extern "C" {
        pub fn _wtoi64_l(_Str: *const u16, _Locale: root::_locale_t) -> ::std::os::raw::c_longlong;
    }
    extern "C" {
        pub fn _wcstoi64(
            _Str: *const u16,
            _EndPtr: *mut *mut u16,
            _Radix: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_longlong;
    }
    extern "C" {
        pub fn _wcstoi64_l(
            _Str: *const u16,
            _EndPtr: *mut *mut u16,
            _Radix: ::std::os::raw::c_int,
            _Locale: root::_locale_t,
        ) -> ::std::os::raw::c_longlong;
    }
    extern "C" {
        pub fn _wcstoui64(
            _Str: *const u16,
            _EndPtr: *mut *mut u16,
            _Radix: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_ulonglong;
    }
    extern "C" {
        pub fn _wcstoui64_l(
            _Str: *const u16,
            _EndPtr: *mut *mut u16,
            _Radix: ::std::os::raw::c_int,
            _Locale: root::_locale_t,
        ) -> ::std::os::raw::c_ulonglong;
    }
    extern "C" {
        pub fn _putenv(_EnvString: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _wputenv(_EnvString: *const u16) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _fullpath(
            _FullPath: *mut ::std::os::raw::c_char,
            _Path: *const ::std::os::raw::c_char,
            _SizeInBytes: usize,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn _ecvt(
            _Val: f64,
            _NumOfDigits: ::std::os::raw::c_int,
            _PtDec: *mut ::std::os::raw::c_int,
            _PtSign: *mut ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn _fcvt(
            _Val: f64,
            _NumOfDec: ::std::os::raw::c_int,
            _PtDec: *mut ::std::os::raw::c_int,
            _PtSign: *mut ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn _gcvt(
            _Val: f64,
            _NumOfDigits: ::std::os::raw::c_int,
            _DstBuf: *mut ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn _atodbl(
            _Result: *mut root::_CRT_DOUBLE,
            _Str: *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _atoldbl(
            _Result: *mut root::_LDOUBLE,
            _Str: *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _atoflt(
            _Result: *mut root::_CRT_FLOAT,
            _Str: *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _atodbl_l(
            _Result: *mut root::_CRT_DOUBLE,
            _Str: *mut ::std::os::raw::c_char,
            _Locale: root::_locale_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _atoldbl_l(
            _Result: *mut root::_LDOUBLE,
            _Str: *mut ::std::os::raw::c_char,
            _Locale: root::_locale_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _atoflt_l(
            _Result: *mut root::_CRT_FLOAT,
            _Str: *mut ::std::os::raw::c_char,
            _Locale: root::_locale_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _lrotl(
            arg1: ::std::os::raw::c_ulong,
            arg2: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        pub fn _lrotr(
            arg1: ::std::os::raw::c_ulong,
            arg2: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        pub fn _makepath(
            _Path: *mut ::std::os::raw::c_char,
            _Drive: *const ::std::os::raw::c_char,
            _Dir: *const ::std::os::raw::c_char,
            _Filename: *const ::std::os::raw::c_char,
            _Ext: *const ::std::os::raw::c_char,
        );
    }
    extern "C" {
        pub fn _onexit(_Func: root::_onexit_t) -> root::_onexit_t;
    }
    extern "C" {
        pub fn perror(_ErrMsg: *const ::std::os::raw::c_char);
    }
    extern "C" {
        pub fn _rotl64(
            _Val: ::std::os::raw::c_ulonglong,
            _Shift: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_ulonglong;
    }
    extern "C" {
        pub fn _rotr64(
            Value: ::std::os::raw::c_ulonglong,
            Shift: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_ulonglong;
    }
    extern "C" {
        pub fn _rotr(
            _Val: ::std::os::raw::c_uint,
            _Shift: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_uint;
    }
    extern "C" {
        pub fn _rotl(
            _Val: ::std::os::raw::c_uint,
            _Shift: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_uint;
    }
    extern "C" {
        pub fn _searchenv(
            _Filename: *const ::std::os::raw::c_char,
            _EnvVar: *const ::std::os::raw::c_char,
            _ResultPath: *mut ::std::os::raw::c_char,
        );
    }
    extern "C" {
        pub fn _splitpath(
            _FullPath: *const ::std::os::raw::c_char,
            _Drive: *mut ::std::os::raw::c_char,
            _Dir: *mut ::std::os::raw::c_char,
            _Filename: *mut ::std::os::raw::c_char,
            _Ext: *mut ::std::os::raw::c_char,
        );
    }
    extern "C" {
        pub fn _swab(
            _Buf1: *mut ::std::os::raw::c_char,
            _Buf2: *mut ::std::os::raw::c_char,
            _SizeInBytes: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        pub fn _wfullpath(_FullPath: *mut u16, _Path: *const u16, _SizeInWords: usize) -> *mut u16;
    }
    extern "C" {
        pub fn _wmakepath(
            _ResultPath: *mut u16,
            _Drive: *const u16,
            _Dir: *const u16,
            _Filename: *const u16,
            _Ext: *const u16,
        );
    }
    extern "C" {
        pub fn _wperror(_ErrMsg: *const u16);
    }
    extern "C" {
        pub fn _wsearchenv(_Filename: *const u16, _EnvVar: *const u16, _ResultPath: *mut u16);
    }
    extern "C" {
        pub fn _wsplitpath(
            _FullPath: *const u16,
            _Drive: *mut u16,
            _Dir: *mut u16,
            _Filename: *mut u16,
            _Ext: *mut u16,
        );
    }
    extern "C" {
        pub fn _beep(_Frequency: ::std::os::raw::c_uint, _Duration: ::std::os::raw::c_uint);
    }
    extern "C" {
        pub fn _seterrormode(_Mode: ::std::os::raw::c_int);
    }
    extern "C" {
        pub fn _sleep(_Duration: ::std::os::raw::c_ulong);
    }
    extern "C" {
        pub fn ecvt(
            _Val: f64,
            _NumOfDigits: ::std::os::raw::c_int,
            _PtDec: *mut ::std::os::raw::c_int,
            _PtSign: *mut ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn fcvt(
            _Val: f64,
            _NumOfDec: ::std::os::raw::c_int,
            _PtDec: *mut ::std::os::raw::c_int,
            _PtSign: *mut ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn gcvt(
            _Val: f64,
            _NumOfDigits: ::std::os::raw::c_int,
            _DstBuf: *mut ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn itoa(
            _Val: ::std::os::raw::c_int,
            _DstBuf: *mut ::std::os::raw::c_char,
            _Radix: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn ltoa(
            _Val: ::std::os::raw::c_long,
            _DstBuf: *mut ::std::os::raw::c_char,
            _Radix: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn putenv(_EnvString: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn swab(
            _Buf1: *mut ::std::os::raw::c_char,
            _Buf2: *mut ::std::os::raw::c_char,
            _SizeInBytes: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        pub fn ultoa(
            _Val: ::std::os::raw::c_ulong,
            _Dstbuf: *mut ::std::os::raw::c_char,
            _Radix: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn onexit(_Func: root::_onexit_t) -> root::_onexit_t;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct lldiv_t {
        pub quot: ::std::os::raw::c_longlong,
        pub rem: ::std::os::raw::c_longlong,
    }
    #[test]
    fn bindgen_test_layout_lldiv_t() {
        const UNINIT: ::std::mem::MaybeUninit<lldiv_t> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<lldiv_t>(),
            16usize,
            concat!("Size of: ", stringify!(lldiv_t))
        );
        assert_eq!(
            ::std::mem::align_of::<lldiv_t>(),
            8usize,
            concat!("Alignment of ", stringify!(lldiv_t))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(lldiv_t),
                "::",
                stringify!(quot)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(lldiv_t),
                "::",
                stringify!(rem)
            )
        );
    }
    extern "C" {
        pub fn lldiv(
            arg1: ::std::os::raw::c_longlong,
            arg2: ::std::os::raw::c_longlong,
        ) -> root::lldiv_t;
    }
    extern "C" {
        pub fn llabs(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
    }
    extern "C" {
        pub fn strtoll(
            arg1: *const ::std::os::raw::c_char,
            arg2: *mut *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_longlong;
    }
    extern "C" {
        pub fn strtoull(
            arg1: *const ::std::os::raw::c_char,
            arg2: *mut *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_ulonglong;
    }
    extern "C" {
        pub fn atoll(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
    }
    extern "C" {
        pub fn wtoll(arg1: *const u16) -> ::std::os::raw::c_longlong;
    }
    extern "C" {
        pub fn lltoa(
            arg1: ::std::os::raw::c_longlong,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn ulltoa(
            arg1: ::std::os::raw::c_ulonglong,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_char;
    }
    extern "C" {
        pub fn lltow(
            arg1: ::std::os::raw::c_longlong,
            arg2: *mut u16,
            arg3: ::std::os::raw::c_int,
        ) -> *mut u16;
    }
    extern "C" {
        pub fn ulltow(
            arg1: ::std::os::raw::c_ulonglong,
            arg2: *mut u16,
            arg3: ::std::os::raw::c_int,
        ) -> *mut u16;
    }
    extern "C" {
        pub fn bsearch_s(
            _Key: *const ::std::os::raw::c_void,
            _Base: *const ::std::os::raw::c_void,
            _NumOfElements: root::rsize_t,
            _SizeOfElements: root::rsize_t,
            _PtFuncCompare: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut ::std::os::raw::c_void,
                    arg2: *const ::std::os::raw::c_void,
                    arg3: *const ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_int,
            >,
            _Context: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        pub fn _dupenv_s(
            _PBuffer: *mut *mut ::std::os::raw::c_char,
            _PBufferSizeInBytes: *mut usize,
            _VarName: *const ::std::os::raw::c_char,
        ) -> root::errno_t;
    }
    extern "C" {
        pub fn getenv_s(
            _ReturnSize: *mut usize,
            _DstBuf: *mut ::std::os::raw::c_char,
            _DstSize: root::rsize_t,
            _VarName: *const ::std::os::raw::c_char,
        ) -> root::errno_t;
    }
    extern "C" {
        pub fn _itoa_s(
            _Value: ::std::os::raw::c_int,
            _DstBuf: *mut ::std::os::raw::c_char,
            _Size: usize,
            _Radix: ::std::os::raw::c_int,
        ) -> root::errno_t;
    }
    extern "C" {
        pub fn _i64toa_s(
            _Val: ::std::os::raw::c_longlong,
            _DstBuf: *mut ::std::os::raw::c_char,
            _Size: usize,
            _Radix: ::std::os::raw::c_int,
        ) -> root::errno_t;
    }
    extern "C" {
        pub fn _ui64toa_s(
            _Val: ::std::os::raw::c_ulonglong,
            _DstBuf: *mut ::std::os::raw::c_char,
            _Size: usize,
            _Radix: ::std::os::raw::c_int,
        ) -> root::errno_t;
    }
    extern "C" {
        pub fn _ltoa_s(
            _Val: ::std::os::raw::c_long,
            _DstBuf: *mut ::std::os::raw::c_char,
            _Size: usize,
            _Radix: ::std::os::raw::c_int,
        ) -> root::errno_t;
    }
    extern "C" {
        pub fn mbstowcs_s(
            _PtNumOfCharConverted: *mut usize,
            _DstBuf: *mut u16,
            _SizeInWords: usize,
            _SrcBuf: *const ::std::os::raw::c_char,
            _MaxCount: usize,
        ) -> root::errno_t;
    }
    extern "C" {
        pub fn _mbstowcs_s_l(
            _PtNumOfCharConverted: *mut usize,
            _DstBuf: *mut u16,
            _SizeInWords: usize,
            _SrcBuf: *const ::std::os::raw::c_char,
            _MaxCount: usize,
            _Locale: root::_locale_t,
        ) -> root::errno_t;
    }
    extern "C" {
        pub fn _ultoa_s(
            _Val: ::std::os::raw::c_ulong,
            _DstBuf: *mut ::std::os::raw::c_char,
            _Size: usize,
            _Radix: ::std::os::raw::c_int,
        ) -> root::errno_t;
    }
    extern "C" {
        pub fn wctomb_s(
            _SizeConverted: *mut ::std::os::raw::c_int,
            _MbCh: *mut ::std::os::raw::c_char,
            _SizeInBytes: root::rsize_t,
            _WCh: u16,
        ) -> root::errno_t;
    }
    extern "C" {
        pub fn _wctomb_s_l(
            _SizeConverted: *mut ::std::os::raw::c_int,
            _MbCh: *mut ::std::os::raw::c_char,
            _SizeInBytes: usize,
            _WCh: u16,
            _Locale: root::_locale_t,
        ) -> root::errno_t;
    }
    extern "C" {
        pub fn wcstombs_s(
            _PtNumOfCharConverted: *mut usize,
            _Dst: *mut ::std::os::raw::c_char,
            _DstSizeInBytes: usize,
            _Src: *const u16,
            _MaxCountInBytes: usize,
        ) -> root::errno_t;
    }
    extern "C" {
        pub fn _wcstombs_s_l(
            _PtNumOfCharConverted: *mut usize,
            _Dst: *mut ::std::os::raw::c_char,
            _DstSizeInBytes: usize,
            _Src: *const u16,
            _MaxCountInBytes: usize,
            _Locale: root::_locale_t,
        ) -> root::errno_t;
    }
    extern "C" {
        pub fn _ecvt_s(
            _DstBuf: *mut ::std::os::raw::c_char,
            _Size: usize,
            _Val: f64,
            _NumOfDights: ::std::os::raw::c_int,
            _PtDec: *mut ::std::os::raw::c_int,
            _PtSign: *mut ::std::os::raw::c_int,
        ) -> root::errno_t;
    }
    extern "C" {
        pub fn _fcvt_s(
            _DstBuf: *mut ::std::os::raw::c_char,
            _Size: usize,
            _Val: f64,
            _NumOfDec: ::std::os::raw::c_int,
            _PtDec: *mut ::std::os::raw::c_int,
            _PtSign: *mut ::std::os::raw::c_int,
        ) -> root::errno_t;
    }
    extern "C" {
        pub fn _gcvt_s(
            _DstBuf: *mut ::std::os::raw::c_char,
            _Size: usize,
            _Val: f64,
            _NumOfDigits: ::std::os::raw::c_int,
        ) -> root::errno_t;
    }
    extern "C" {
        pub fn _makepath_s(
            _PathResult: *mut ::std::os::raw::c_char,
            _Size: usize,
            _Drive: *const ::std::os::raw::c_char,
            _Dir: *const ::std::os::raw::c_char,
            _Filename: *const ::std::os::raw::c_char,
            _Ext: *const ::std::os::raw::c_char,
        ) -> root::errno_t;
    }
    extern "C" {
        pub fn _putenv_s(
            _Name: *const ::std::os::raw::c_char,
            _Value: *const ::std::os::raw::c_char,
        ) -> root::errno_t;
    }
    extern "C" {
        pub fn _searchenv_s(
            _Filename: *const ::std::os::raw::c_char,
            _EnvVar: *const ::std::os::raw::c_char,
            _ResultPath: *mut ::std::os::raw::c_char,
            _SizeInBytes: usize,
        ) -> root::errno_t;
    }
    extern "C" {
        pub fn _splitpath_s(
            _FullPath: *const ::std::os::raw::c_char,
            _Drive: *mut ::std::os::raw::c_char,
            _DriveSize: usize,
            _Dir: *mut ::std::os::raw::c_char,
            _DirSize: usize,
            _Filename: *mut ::std::os::raw::c_char,
            _FilenameSize: usize,
            _Ext: *mut ::std::os::raw::c_char,
            _ExtSize: usize,
        ) -> root::errno_t;
    }
    extern "C" {
        pub fn qsort_s(
            _Base: *mut ::std::os::raw::c_void,
            _NumOfElements: usize,
            _SizeOfElements: usize,
            _PtFuncCompare: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut ::std::os::raw::c_void,
                    arg2: *const ::std::os::raw::c_void,
                    arg3: *const ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_int,
            >,
            _Context: *mut ::std::os::raw::c_void,
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _heapinfo {
        pub _pentry: *mut ::std::os::raw::c_int,
        pub _size: usize,
        pub _useflag: ::std::os::raw::c_int,
    }
    #[test]
    fn bindgen_test_layout__heapinfo() {
        const UNINIT: ::std::mem::MaybeUninit<_heapinfo> = ::std::mem::MaybeUninit::uninit();
        let ptr = UNINIT.as_ptr();
        assert_eq!(
            ::std::mem::size_of::<_heapinfo>(),
            24usize,
            concat!("Size of: ", stringify!(_heapinfo))
        );
        assert_eq!(
            ::std::mem::align_of::<_heapinfo>(),
            8usize,
            concat!("Alignment of ", stringify!(_heapinfo))
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr)._pentry) as usize - ptr as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_heapinfo),
                "::",
                stringify!(_pentry)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr)._size) as usize - ptr as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_heapinfo),
                "::",
                stringify!(_size)
            )
        );
        assert_eq!(
            unsafe { ::std::ptr::addr_of!((*ptr)._useflag) as usize - ptr as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_heapinfo),
                "::",
                stringify!(_useflag)
            )
        );
    }
    pub type _HEAPINFO = root::_heapinfo;
    extern "C" {
        pub static mut _amblksiz: ::std::os::raw::c_uint;
    }
    extern "C" {
        pub fn _resetstkoflw() -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _set_malloc_crt_max_wait(
            _NewValue: ::std::os::raw::c_ulong,
        ) -> ::std::os::raw::c_ulong;
    }
    extern "C" {
        pub fn _expand(
            _Memory: *mut ::std::os::raw::c_void,
            _NewSize: usize,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        pub fn _msize(_Memory: *mut ::std::os::raw::c_void) -> usize;
    }
    extern "C" {
        pub fn _get_sbh_threshold() -> usize;
    }
    extern "C" {
        pub fn _set_sbh_threshold(_NewValue: usize) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _set_amblksiz(_Value: usize) -> root::errno_t;
    }
    extern "C" {
        pub fn _get_amblksiz(_Value: *mut usize) -> root::errno_t;
    }
    extern "C" {
        pub fn _heapadd(
            _Memory: *mut ::std::os::raw::c_void,
            _Size: usize,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _heapchk() -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _heapmin() -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _heapset(_Fill: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _heapwalk(_EntryInfo: *mut root::_HEAPINFO) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _heapused(_Used: *mut usize, _Commit: *mut usize) -> usize;
    }
    extern "C" {
        pub fn _get_heap_handle() -> isize;
    }
    pub mod DSP {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Buffer {
            pub data: *mut f32,
            pub writeIndex: usize,
            pub readIndex: usize,
            pub numSamples: usize,
        }
        #[test]
        fn bindgen_test_layout_Buffer() {
            const UNINIT: ::std::mem::MaybeUninit<Buffer> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<Buffer>(),
                32usize,
                concat!("Size of: ", stringify!(Buffer))
            );
            assert_eq!(
                ::std::mem::align_of::<Buffer>(),
                8usize,
                concat!("Alignment of ", stringify!(Buffer))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Buffer),
                    "::",
                    stringify!(data)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).writeIndex) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Buffer),
                    "::",
                    stringify!(writeIndex)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).readIndex) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Buffer),
                    "::",
                    stringify!(readIndex)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).numSamples) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Buffer),
                    "::",
                    stringify!(numSamples)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP6Buffer10initializeEy"]
            pub fn Buffer_initialize(this: *mut root::DSP::Buffer, size: usize);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP6Buffer5writeEf"]
            pub fn Buffer_write(this: *mut root::DSP::Buffer, sample: f32);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP6Buffer4readEv"]
            pub fn Buffer_read(this: *mut root::DSP::Buffer) -> f32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP6Buffer9getSampleEy"]
            pub fn Buffer_getSample(this: *mut root::DSP::Buffer, index: usize) -> f32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP6Buffer9setSampleEfy"]
            pub fn Buffer_setSample(this: *mut root::DSP::Buffer, sample: f32, index: usize);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP6Buffer14shiftReadIndexEi"]
            pub fn Buffer_shiftReadIndex(
                this: *mut root::DSP::Buffer,
                amount: ::std::os::raw::c_int,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP6Buffer12setReadIndexEi"]
            pub fn Buffer_setReadIndex(this: *mut root::DSP::Buffer, index: ::std::os::raw::c_int);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP6Buffer13setWriteIndexEi"]
            pub fn Buffer_setWriteIndex(this: *mut root::DSP::Buffer, index: ::std::os::raw::c_int);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP6Buffer13getWriteIndexEv"]
            pub fn Buffer_getWriteIndex(this: *mut root::DSP::Buffer) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP6Buffer12getReadIndexEv"]
            pub fn Buffer_getReadIndex(this: *mut root::DSP::Buffer) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP6Buffer6resizeEy"]
            pub fn Buffer_resize(this: *mut root::DSP::Buffer, size: usize);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP6BufferC1Ev"]
            pub fn Buffer_Buffer(this: *mut root::DSP::Buffer);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP6BufferC1Ey"]
            pub fn Buffer_Buffer1(this: *mut root::DSP::Buffer, size: usize);
        }
        impl Buffer {
            #[inline]
            pub unsafe fn initialize(&mut self, size: usize) {
                Buffer_initialize(self, size)
            }
            #[inline]
            pub unsafe fn write(&mut self, sample: f32) {
                Buffer_write(self, sample)
            }
            #[inline]
            pub unsafe fn read(&mut self) -> f32 {
                Buffer_read(self)
            }
            #[inline]
            pub unsafe fn getSample(&mut self, index: usize) -> f32 {
                Buffer_getSample(self, index)
            }
            #[inline]
            pub unsafe fn setSample(&mut self, sample: f32, index: usize) {
                Buffer_setSample(self, sample, index)
            }
            #[inline]
            pub unsafe fn shiftReadIndex(&mut self, amount: ::std::os::raw::c_int) {
                Buffer_shiftReadIndex(self, amount)
            }
            #[inline]
            pub unsafe fn setReadIndex(&mut self, index: ::std::os::raw::c_int) {
                Buffer_setReadIndex(self, index)
            }
            #[inline]
            pub unsafe fn setWriteIndex(&mut self, index: ::std::os::raw::c_int) {
                Buffer_setWriteIndex(self, index)
            }
            #[inline]
            pub unsafe fn getWriteIndex(&mut self) -> ::std::os::raw::c_int {
                Buffer_getWriteIndex(self)
            }
            #[inline]
            pub unsafe fn getReadIndex(&mut self) -> ::std::os::raw::c_int {
                Buffer_getReadIndex(self)
            }
            #[inline]
            pub unsafe fn resize(&mut self, size: usize) {
                Buffer_resize(self, size)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Buffer_Buffer(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(size: usize) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Buffer_Buffer1(__bindgen_tmp.as_mut_ptr(), size);
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        pub struct BiQuadFilter__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct BiQuadFilter {
            pub vtable_: *const BiQuadFilter__bindgen_vtable,
            pub numChannels: ::std::os::raw::c_int,
            pub fs: f64,
            pub fc: ::std::os::raw::c_int,
            pub a0: f32,
            pub a1: f32,
            pub a2: f32,
            pub b1: f32,
            pub b2: f32,
            pub c0: f32,
            pub d0: f32,
            pub inputBuffer: [u64; 3usize],
            pub outputBuffer: [u64; 3usize],
        }
        #[test]
        fn bindgen_test_layout_BiQuadFilter() {
            const UNINIT: ::std::mem::MaybeUninit<BiQuadFilter> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<BiQuadFilter>(),
                104usize,
                concat!("Size of: ", stringify!(BiQuadFilter))
            );
            assert_eq!(
                ::std::mem::align_of::<BiQuadFilter>(),
                8usize,
                concat!("Alignment of ", stringify!(BiQuadFilter))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).numChannels) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(BiQuadFilter),
                    "::",
                    stringify!(numChannels)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).fs) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(BiQuadFilter),
                    "::",
                    stringify!(fs)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).fc) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(BiQuadFilter),
                    "::",
                    stringify!(fc)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).a0) as usize - ptr as usize },
                28usize,
                concat!(
                    "Offset of field: ",
                    stringify!(BiQuadFilter),
                    "::",
                    stringify!(a0)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).a1) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(BiQuadFilter),
                    "::",
                    stringify!(a1)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).a2) as usize - ptr as usize },
                36usize,
                concat!(
                    "Offset of field: ",
                    stringify!(BiQuadFilter),
                    "::",
                    stringify!(a2)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).b1) as usize - ptr as usize },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(BiQuadFilter),
                    "::",
                    stringify!(b1)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).b2) as usize - ptr as usize },
                44usize,
                concat!(
                    "Offset of field: ",
                    stringify!(BiQuadFilter),
                    "::",
                    stringify!(b2)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).c0) as usize - ptr as usize },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(BiQuadFilter),
                    "::",
                    stringify!(c0)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).d0) as usize - ptr as usize },
                52usize,
                concat!(
                    "Offset of field: ",
                    stringify!(BiQuadFilter),
                    "::",
                    stringify!(d0)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).inputBuffer) as usize - ptr as usize },
                56usize,
                concat!(
                    "Offset of field: ",
                    stringify!(BiQuadFilter),
                    "::",
                    stringify!(inputBuffer)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).outputBuffer) as usize - ptr as usize },
                80usize,
                concat!(
                    "Offset of field: ",
                    stringify!(BiQuadFilter),
                    "::",
                    stringify!(outputBuffer)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP12BiQuadFilter10nextSampleEfi"]
            pub fn BiQuadFilter_nextSample(
                this: *mut root::DSP::BiQuadFilter,
                sample: f32,
                channel: ::std::os::raw::c_int,
            ) -> f32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP12BiQuadFilter13setSampleRateEd"]
            pub fn BiQuadFilter_setSampleRate(this: *mut root::DSP::BiQuadFilter, sampleRate: f64);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP12BiQuadFilter13getSampleRateEv"]
            pub fn BiQuadFilter_getSampleRate(this: *mut root::DSP::BiQuadFilter) -> f64;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP12BiQuadFilterC1Eiid"]
            pub fn BiQuadFilter_BiQuadFilter(
                this: *mut root::DSP::BiQuadFilter,
                numChannels: ::std::os::raw::c_int,
                centerFrequency: ::std::os::raw::c_int,
                sampleRate: f64,
            );
        }
        impl BiQuadFilter {
            #[inline]
            pub unsafe fn nextSample(
                &mut self,
                sample: f32,
                channel: ::std::os::raw::c_int,
            ) -> f32 {
                BiQuadFilter_nextSample(self, sample, channel)
            }
            #[inline]
            pub unsafe fn setSampleRate(&mut self, sampleRate: f64) {
                BiQuadFilter_setSampleRate(self, sampleRate)
            }
            #[inline]
            pub unsafe fn getSampleRate(&mut self) -> f64 {
                BiQuadFilter_getSampleRate(self)
            }
            #[inline]
            pub unsafe fn new(
                numChannels: ::std::os::raw::c_int,
                centerFrequency: ::std::os::raw::c_int,
                sampleRate: f64,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                BiQuadFilter_BiQuadFilter(
                    __bindgen_tmp.as_mut_ptr(),
                    numChannels,
                    centerFrequency,
                    sampleRate,
                );
                __bindgen_tmp.assume_init()
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP12BiQuadFilter6updateEfff"]
            pub fn BiQuadFilter_update(this: *mut ::std::os::raw::c_void, fc: f32, fs: f32, G: f32);
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct HighPassIIR {
            pub _base: root::DSP::BiQuadFilter,
            pub thetac: f32,
            pub omegac: f32,
            pub K: f32,
            pub sigma: f32,
        }
        #[test]
        fn bindgen_test_layout_HighPassIIR() {
            const UNINIT: ::std::mem::MaybeUninit<HighPassIIR> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<HighPassIIR>(),
                120usize,
                concat!("Size of: ", stringify!(HighPassIIR))
            );
            assert_eq!(
                ::std::mem::align_of::<HighPassIIR>(),
                8usize,
                concat!("Alignment of ", stringify!(HighPassIIR))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).thetac) as usize - ptr as usize },
                104usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HighPassIIR),
                    "::",
                    stringify!(thetac)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).omegac) as usize - ptr as usize },
                108usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HighPassIIR),
                    "::",
                    stringify!(omegac)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).K) as usize - ptr as usize },
                112usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HighPassIIR),
                    "::",
                    stringify!(K)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).sigma) as usize - ptr as usize },
                116usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HighPassIIR),
                    "::",
                    stringify!(sigma)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP11HighPassIIRC1Eiff"]
            pub fn HighPassIIR_HighPassIIR(
                this: *mut root::DSP::HighPassIIR,
                numChannels: ::std::os::raw::c_int,
                fc: f32,
                fs: f32,
            );
        }
        impl HighPassIIR {
            #[inline]
            pub unsafe fn new(numChannels: ::std::os::raw::c_int, fc: f32, fs: f32) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                HighPassIIR_HighPassIIR(__bindgen_tmp.as_mut_ptr(), numChannels, fc, fs);
                __bindgen_tmp.assume_init()
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP11HighPassIIR6updateEfff"]
            pub fn HighPassIIR_update(this: *mut ::std::os::raw::c_void, fc: f32, fs: f32, G: f32);
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct LowPassIIR {
            pub _base: root::DSP::BiQuadFilter,
            pub thetac: f32,
            pub omegac: f32,
            pub K: f32,
            pub sigma: f32,
        }
        #[test]
        fn bindgen_test_layout_LowPassIIR() {
            const UNINIT: ::std::mem::MaybeUninit<LowPassIIR> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<LowPassIIR>(),
                120usize,
                concat!("Size of: ", stringify!(LowPassIIR))
            );
            assert_eq!(
                ::std::mem::align_of::<LowPassIIR>(),
                8usize,
                concat!("Alignment of ", stringify!(LowPassIIR))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).thetac) as usize - ptr as usize },
                104usize,
                concat!(
                    "Offset of field: ",
                    stringify!(LowPassIIR),
                    "::",
                    stringify!(thetac)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).omegac) as usize - ptr as usize },
                108usize,
                concat!(
                    "Offset of field: ",
                    stringify!(LowPassIIR),
                    "::",
                    stringify!(omegac)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).K) as usize - ptr as usize },
                112usize,
                concat!(
                    "Offset of field: ",
                    stringify!(LowPassIIR),
                    "::",
                    stringify!(K)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).sigma) as usize - ptr as usize },
                116usize,
                concat!(
                    "Offset of field: ",
                    stringify!(LowPassIIR),
                    "::",
                    stringify!(sigma)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP10LowPassIIRC1Eiff"]
            pub fn LowPassIIR_LowPassIIR(
                this: *mut root::DSP::LowPassIIR,
                numChannels: ::std::os::raw::c_int,
                fc: f32,
                fs: f32,
            );
        }
        impl LowPassIIR {
            #[inline]
            pub unsafe fn new(numChannels: ::std::os::raw::c_int, fc: f32, fs: f32) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                LowPassIIR_LowPassIIR(__bindgen_tmp.as_mut_ptr(), numChannels, fc, fs);
                __bindgen_tmp.assume_init()
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP10LowPassIIR6updateEfff"]
            pub fn LowPassIIR_update(this: *mut ::std::os::raw::c_void, fc: f32, fs: f32, G: f32);
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct PeakIIR {
            pub _base: root::DSP::BiQuadFilter,
            pub thetac: f32,
            pub mu: f32,
            pub sigma: f32,
            pub beta: f32,
            pub gamma: f32,
            pub Q: f32,
            pub G: ::std::os::raw::c_int,
        }
        #[test]
        fn bindgen_test_layout_PeakIIR() {
            const UNINIT: ::std::mem::MaybeUninit<PeakIIR> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<PeakIIR>(),
                136usize,
                concat!("Size of: ", stringify!(PeakIIR))
            );
            assert_eq!(
                ::std::mem::align_of::<PeakIIR>(),
                8usize,
                concat!("Alignment of ", stringify!(PeakIIR))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).thetac) as usize - ptr as usize },
                104usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PeakIIR),
                    "::",
                    stringify!(thetac)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).mu) as usize - ptr as usize },
                108usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PeakIIR),
                    "::",
                    stringify!(mu)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).sigma) as usize - ptr as usize },
                112usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PeakIIR),
                    "::",
                    stringify!(sigma)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).beta) as usize - ptr as usize },
                116usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PeakIIR),
                    "::",
                    stringify!(beta)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).gamma) as usize - ptr as usize },
                120usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PeakIIR),
                    "::",
                    stringify!(gamma)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).Q) as usize - ptr as usize },
                124usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PeakIIR),
                    "::",
                    stringify!(Q)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).G) as usize - ptr as usize },
                128usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PeakIIR),
                    "::",
                    stringify!(G)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP7PeakIIRC1Eiffff"]
            pub fn PeakIIR_PeakIIR(
                this: *mut root::DSP::PeakIIR,
                numChannels: ::std::os::raw::c_int,
                G: f32,
                fc: f32,
                Q: f32,
                fs: f32,
            );
        }
        impl PeakIIR {
            #[inline]
            pub unsafe fn new(
                numChannels: ::std::os::raw::c_int,
                G: f32,
                fc: f32,
                Q: f32,
                fs: f32,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                PeakIIR_PeakIIR(__bindgen_tmp.as_mut_ptr(), numChannels, G, fc, Q, fs);
                __bindgen_tmp.assume_init()
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP7PeakIIR6updateEfff"]
            pub fn PeakIIR_update(this: *mut ::std::os::raw::c_void, fc: f32, fs: f32, G: f32);
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct EnvelopeDetector {
            pub ta: f32,
            pub tr: f32,
            pub tc: f32,
            pub digital: bool,
            pub fs: f32,
            pub yn1: f32,
        }
        #[test]
        fn bindgen_test_layout_EnvelopeDetector() {
            const UNINIT: ::std::mem::MaybeUninit<EnvelopeDetector> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<EnvelopeDetector>(),
                24usize,
                concat!("Size of: ", stringify!(EnvelopeDetector))
            );
            assert_eq!(
                ::std::mem::align_of::<EnvelopeDetector>(),
                4usize,
                concat!("Alignment of ", stringify!(EnvelopeDetector))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).ta) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(EnvelopeDetector),
                    "::",
                    stringify!(ta)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).tr) as usize - ptr as usize },
                4usize,
                concat!(
                    "Offset of field: ",
                    stringify!(EnvelopeDetector),
                    "::",
                    stringify!(tr)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).tc) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(EnvelopeDetector),
                    "::",
                    stringify!(tc)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).digital) as usize - ptr as usize },
                12usize,
                concat!(
                    "Offset of field: ",
                    stringify!(EnvelopeDetector),
                    "::",
                    stringify!(digital)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).fs) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(EnvelopeDetector),
                    "::",
                    stringify!(fs)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).yn1) as usize - ptr as usize },
                20usize,
                concat!(
                    "Offset of field: ",
                    stringify!(EnvelopeDetector),
                    "::",
                    stringify!(yn1)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP16EnvelopeDetector12getNextValueEf"]
            pub fn EnvelopeDetector_getNextValue(
                this: *mut root::DSP::EnvelopeDetector,
                input: f32,
            ) -> f32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP16EnvelopeDetector9setParamsEfff"]
            pub fn EnvelopeDetector_setParams(
                this: *mut root::DSP::EnvelopeDetector,
                releaseTimeMs: f32,
                attackTimeMs: f32,
                sampleRate: f32,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP16EnvelopeDetectorC1Eb"]
            pub fn EnvelopeDetector_EnvelopeDetector(
                this: *mut root::DSP::EnvelopeDetector,
                isDigital: bool,
            );
        }
        impl EnvelopeDetector {
            #[inline]
            pub unsafe fn getNextValue(&mut self, input: f32) -> f32 {
                EnvelopeDetector_getNextValue(self, input)
            }
            #[inline]
            pub unsafe fn setParams(
                &mut self,
                releaseTimeMs: f32,
                attackTimeMs: f32,
                sampleRate: f32,
            ) {
                EnvelopeDetector_setParams(self, releaseTimeMs, attackTimeMs, sampleRate)
            }
            #[inline]
            pub unsafe fn new(isDigital: bool) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                EnvelopeDetector_EnvelopeDetector(__bindgen_tmp.as_mut_ptr(), isDigital);
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct BezierCurve {
            pub x: [f32; 3usize],
            pub y: [f32; 3usize],
        }
        #[test]
        fn bindgen_test_layout_BezierCurve() {
            const UNINIT: ::std::mem::MaybeUninit<BezierCurve> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<BezierCurve>(),
                24usize,
                concat!("Size of: ", stringify!(BezierCurve))
            );
            assert_eq!(
                ::std::mem::align_of::<BezierCurve>(),
                4usize,
                concat!("Alignment of ", stringify!(BezierCurve))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(BezierCurve),
                    "::",
                    stringify!(x)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
                12usize,
                concat!(
                    "Offset of field: ",
                    stringify!(BezierCurve),
                    "::",
                    stringify!(y)
                )
            );
        }
        extern "C" {
            #[doc = " Set the X and Y values for the points\n used in the curve.  P0 is the start\n point, P1 is the control point,\n and P2 is the end point."]
            #[link_name = "\u{1}_ZN3DSP11BezierCurve3setEffffff"]
            pub fn BezierCurve_set(
                this: *mut root::DSP::BezierCurve,
                x0: f32,
                y0: f32,
                x1: f32,
                y1: f32,
                x2: f32,
                y2: f32,
            );
        }
        extern "C" {
            #[doc = " Approximates t value based on x and\n returns Y"]
            #[link_name = "\u{1}_ZN3DSP11BezierCurve10getValueAtEf"]
            pub fn BezierCurve_getValueAt(this: *mut root::DSP::BezierCurve, input: f32) -> f32;
        }
        extern "C" {
            #[doc = " Default contructor"]
            #[link_name = "\u{1}_ZN3DSP11BezierCurveC1Ev"]
            pub fn BezierCurve_BezierCurve(this: *mut root::DSP::BezierCurve);
        }
        impl BezierCurve {
            #[inline]
            pub unsafe fn set(&mut self, x0: f32, y0: f32, x1: f32, y1: f32, x2: f32, y2: f32) {
                BezierCurve_set(self, x0, y0, x1, y1, x2, y2)
            }
            #[inline]
            pub unsafe fn getValueAt(&mut self, input: f32) -> f32 {
                BezierCurve_getValueAt(self, input)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                BezierCurve_BezierCurve(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct DirectFormOscillator {
            pub theta: f32,
            pub fo: f32,
            pub fs: f32,
            pub b1: f32,
            pub b2: f32,
            pub yn1: f32,
            pub yn2: f32,
            pub init: bool,
        }
        #[test]
        fn bindgen_test_layout_DirectFormOscillator() {
            const UNINIT: ::std::mem::MaybeUninit<DirectFormOscillator> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<DirectFormOscillator>(),
                32usize,
                concat!("Size of: ", stringify!(DirectFormOscillator))
            );
            assert_eq!(
                ::std::mem::align_of::<DirectFormOscillator>(),
                4usize,
                concat!("Alignment of ", stringify!(DirectFormOscillator))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).theta) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(DirectFormOscillator),
                    "::",
                    stringify!(theta)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).fo) as usize - ptr as usize },
                4usize,
                concat!(
                    "Offset of field: ",
                    stringify!(DirectFormOscillator),
                    "::",
                    stringify!(fo)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).fs) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(DirectFormOscillator),
                    "::",
                    stringify!(fs)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).b1) as usize - ptr as usize },
                12usize,
                concat!(
                    "Offset of field: ",
                    stringify!(DirectFormOscillator),
                    "::",
                    stringify!(b1)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).b2) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(DirectFormOscillator),
                    "::",
                    stringify!(b2)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).yn1) as usize - ptr as usize },
                20usize,
                concat!(
                    "Offset of field: ",
                    stringify!(DirectFormOscillator),
                    "::",
                    stringify!(yn1)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).yn2) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(DirectFormOscillator),
                    "::",
                    stringify!(yn2)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).init) as usize - ptr as usize },
                28usize,
                concat!(
                    "Offset of field: ",
                    stringify!(DirectFormOscillator),
                    "::",
                    stringify!(init)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP20DirectFormOscillator12setFrequencyEff"]
            pub fn DirectFormOscillator_setFrequency(
                this: *mut root::DSP::DirectFormOscillator,
                frequency: f32,
                sampleRate: f32,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP20DirectFormOscillator13getNextSampleEf"]
            pub fn DirectFormOscillator_getNextSample(
                this: *mut root::DSP::DirectFormOscillator,
                input: f32,
            ) -> f32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP20DirectFormOscillator5flushEv"]
            pub fn DirectFormOscillator_flush(this: *mut root::DSP::DirectFormOscillator);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP20DirectFormOscillatorC1Ev"]
            pub fn DirectFormOscillator_DirectFormOscillator(
                this: *mut root::DSP::DirectFormOscillator,
            );
        }
        impl DirectFormOscillator {
            #[inline]
            pub unsafe fn setFrequency(&mut self, frequency: f32, sampleRate: f32) {
                DirectFormOscillator_setFrequency(self, frequency, sampleRate)
            }
            #[inline]
            pub unsafe fn getNextSample(&mut self, input: f32) -> f32 {
                DirectFormOscillator_getNextSample(self, input)
            }
            #[inline]
            pub unsafe fn flush(&mut self) {
                DirectFormOscillator_flush(self)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                DirectFormOscillator_DirectFormOscillator(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct GordonSmithOscillator {
            pub yq: f32,
            pub yq1: f32,
            pub yn: f32,
            pub yn1: f32,
            pub epsilon: f32,
            pub theta: f32,
            pub fo: f32,
            pub fs: f32,
            pub init: bool,
        }
        #[test]
        fn bindgen_test_layout_GordonSmithOscillator() {
            const UNINIT: ::std::mem::MaybeUninit<GordonSmithOscillator> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<GordonSmithOscillator>(),
                36usize,
                concat!("Size of: ", stringify!(GordonSmithOscillator))
            );
            assert_eq!(
                ::std::mem::align_of::<GordonSmithOscillator>(),
                4usize,
                concat!("Alignment of ", stringify!(GordonSmithOscillator))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).yq) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GordonSmithOscillator),
                    "::",
                    stringify!(yq)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).yq1) as usize - ptr as usize },
                4usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GordonSmithOscillator),
                    "::",
                    stringify!(yq1)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).yn) as usize - ptr as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GordonSmithOscillator),
                    "::",
                    stringify!(yn)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).yn1) as usize - ptr as usize },
                12usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GordonSmithOscillator),
                    "::",
                    stringify!(yn1)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).epsilon) as usize - ptr as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GordonSmithOscillator),
                    "::",
                    stringify!(epsilon)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).theta) as usize - ptr as usize },
                20usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GordonSmithOscillator),
                    "::",
                    stringify!(theta)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).fo) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GordonSmithOscillator),
                    "::",
                    stringify!(fo)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).fs) as usize - ptr as usize },
                28usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GordonSmithOscillator),
                    "::",
                    stringify!(fs)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).init) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GordonSmithOscillator),
                    "::",
                    stringify!(init)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP21GordonSmithOscillator12setFrequencyEff"]
            pub fn GordonSmithOscillator_setFrequency(
                this: *mut root::DSP::GordonSmithOscillator,
                frequency: f32,
                sampleRate: f32,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP21GordonSmithOscillator13getNextSampleEf"]
            pub fn GordonSmithOscillator_getNextSample(
                this: *mut root::DSP::GordonSmithOscillator,
                input: f32,
            ) -> f32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP21GordonSmithOscillator5flushEv"]
            pub fn GordonSmithOscillator_flush(this: *mut root::DSP::GordonSmithOscillator);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP21GordonSmithOscillatorC1Ev"]
            pub fn GordonSmithOscillator_GordonSmithOscillator(
                this: *mut root::DSP::GordonSmithOscillator,
            );
        }
        impl GordonSmithOscillator {
            #[inline]
            pub unsafe fn setFrequency(&mut self, frequency: f32, sampleRate: f32) {
                GordonSmithOscillator_setFrequency(self, frequency, sampleRate)
            }
            #[inline]
            pub unsafe fn getNextSample(&mut self, input: f32) -> f32 {
                GordonSmithOscillator_getNextSample(self, input)
            }
            #[inline]
            pub unsafe fn flush(&mut self) {
                GordonSmithOscillator_flush(self)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                GordonSmithOscillator_GordonSmithOscillator(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct DigitalDelay {
            pub buffer: root::DSP::Buffer,
            pub wet: f32,
            pub fb: f32,
            pub fs: ::std::os::raw::c_int,
            pub delayAmount: usize,
        }
        #[test]
        fn bindgen_test_layout_DigitalDelay() {
            const UNINIT: ::std::mem::MaybeUninit<DigitalDelay> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<DigitalDelay>(),
                56usize,
                concat!("Size of: ", stringify!(DigitalDelay))
            );
            assert_eq!(
                ::std::mem::align_of::<DigitalDelay>(),
                8usize,
                concat!("Alignment of ", stringify!(DigitalDelay))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(DigitalDelay),
                    "::",
                    stringify!(buffer)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).wet) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(DigitalDelay),
                    "::",
                    stringify!(wet)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).fb) as usize - ptr as usize },
                36usize,
                concat!(
                    "Offset of field: ",
                    stringify!(DigitalDelay),
                    "::",
                    stringify!(fb)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).fs) as usize - ptr as usize },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(DigitalDelay),
                    "::",
                    stringify!(fs)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).delayAmount) as usize - ptr as usize },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(DigitalDelay),
                    "::",
                    stringify!(delayAmount)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP12DigitalDelay13getNextSampleEf"]
            pub fn DigitalDelay_getNextSample(
                this: *mut root::DSP::DigitalDelay,
                sample: f32,
            ) -> f32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP12DigitalDelay6resizeEy"]
            pub fn DigitalDelay_resize(this: *mut root::DSP::DigitalDelay, delayAmount: usize);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP12DigitalDelay5flushEv"]
            pub fn DigitalDelay_flush(this: *mut root::DSP::DigitalDelay);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP12DigitalDelay11setFeedbackEf"]
            pub fn DigitalDelay_setFeedback(this: *mut root::DSP::DigitalDelay, feedback: f32);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP12DigitalDelay6setWetEf"]
            pub fn DigitalDelay_setWet(this: *mut root::DSP::DigitalDelay, wet_amount: f32);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP12DigitalDelayC1Eyff"]
            pub fn DigitalDelay_DigitalDelay(
                this: *mut root::DSP::DigitalDelay,
                delayAmount: usize,
                fb: f32,
                wet: f32,
            );
        }
        impl DigitalDelay {
            #[inline]
            pub unsafe fn getNextSample(&mut self, sample: f32) -> f32 {
                DigitalDelay_getNextSample(self, sample)
            }
            #[inline]
            pub unsafe fn resize(&mut self, delayAmount: usize) {
                DigitalDelay_resize(self, delayAmount)
            }
            #[inline]
            pub unsafe fn flush(&mut self) {
                DigitalDelay_flush(self)
            }
            #[inline]
            pub unsafe fn setFeedback(&mut self, feedback: f32) {
                DigitalDelay_setFeedback(self, feedback)
            }
            #[inline]
            pub unsafe fn setWet(&mut self, wet_amount: f32) {
                DigitalDelay_setWet(self, wet_amount)
            }
            #[inline]
            pub unsafe fn new(delayAmount: usize, fb: f32, wet: f32) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                DigitalDelay_DigitalDelay(__bindgen_tmp.as_mut_ptr(), delayAmount, fb, wet);
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct Compressor {
            pub detector: [u64; 3usize],
            pub attack: f32,
            pub release: f32,
            pub r: f32,
            pub th: f32,
            pub numChannels: ::std::os::raw::c_int,
        }
        #[test]
        fn bindgen_test_layout_Compressor() {
            const UNINIT: ::std::mem::MaybeUninit<Compressor> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<Compressor>(),
                48usize,
                concat!("Size of: ", stringify!(Compressor))
            );
            assert_eq!(
                ::std::mem::align_of::<Compressor>(),
                8usize,
                concat!("Alignment of ", stringify!(Compressor))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).detector) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Compressor),
                    "::",
                    stringify!(detector)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).attack) as usize - ptr as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Compressor),
                    "::",
                    stringify!(attack)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
                28usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Compressor),
                    "::",
                    stringify!(release)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).r) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Compressor),
                    "::",
                    stringify!(r)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).th) as usize - ptr as usize },
                36usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Compressor),
                    "::",
                    stringify!(th)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).numChannels) as usize - ptr as usize },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Compressor),
                    "::",
                    stringify!(numChannels)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP10Compressor9setParamsEfffff"]
            pub fn Compressor_setParams(
                this: *mut root::DSP::Compressor,
                timeAttack: f32,
                timeRelease: f32,
                threshold: f32,
                ratio: f32,
                sampleRate: f32,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP10Compressor13getNextSampleEfi"]
            pub fn Compressor_getNextSample(
                this: *mut root::DSP::Compressor,
                input: f32,
                channel: ::std::os::raw::c_int,
            ) -> f32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP10CompressorC1Eib"]
            pub fn Compressor_Compressor(
                this: *mut root::DSP::Compressor,
                numChannels: ::std::os::raw::c_int,
                isDigital: bool,
            );
        }
        impl Compressor {
            #[inline]
            pub unsafe fn setParams(
                &mut self,
                timeAttack: f32,
                timeRelease: f32,
                threshold: f32,
                ratio: f32,
                sampleRate: f32,
            ) {
                Compressor_setParams(self, timeAttack, timeRelease, threshold, ratio, sampleRate)
            }
            #[inline]
            pub unsafe fn getNextSample(
                &mut self,
                input: f32,
                channel: ::std::os::raw::c_int,
            ) -> f32 {
                Compressor_getNextSample(self, input, channel)
            }
            #[inline]
            pub unsafe fn new(numChannels: ::std::os::raw::c_int, isDigital: bool) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Compressor_Compressor(__bindgen_tmp.as_mut_ptr(), numChannels, isDigital);
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ModulatedDelay {
            pub buffer: root::DSP::Buffer,
            pub osc: root::DSP::GordonSmithOscillator,
            pub wet: f32,
            pub fb: f32,
            pub fs: ::std::os::raw::c_int,
            pub depth: f32,
            pub centerDelay: ::std::os::raw::c_int,
            pub prevDelay: ::std::os::raw::c_int,
            pub scalar: ::std::os::raw::c_int,
            pub oscFreq: f32,
            pub delayRange: ::std::os::raw::c_int,
        }
        #[test]
        fn bindgen_test_layout_ModulatedDelay() {
            const UNINIT: ::std::mem::MaybeUninit<ModulatedDelay> =
                ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<ModulatedDelay>(),
                104usize,
                concat!("Size of: ", stringify!(ModulatedDelay))
            );
            assert_eq!(
                ::std::mem::align_of::<ModulatedDelay>(),
                8usize,
                concat!("Alignment of ", stringify!(ModulatedDelay))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ModulatedDelay),
                    "::",
                    stringify!(buffer)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).osc) as usize - ptr as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ModulatedDelay),
                    "::",
                    stringify!(osc)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).wet) as usize - ptr as usize },
                68usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ModulatedDelay),
                    "::",
                    stringify!(wet)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).fb) as usize - ptr as usize },
                72usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ModulatedDelay),
                    "::",
                    stringify!(fb)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).fs) as usize - ptr as usize },
                76usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ModulatedDelay),
                    "::",
                    stringify!(fs)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize },
                80usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ModulatedDelay),
                    "::",
                    stringify!(depth)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).centerDelay) as usize - ptr as usize },
                84usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ModulatedDelay),
                    "::",
                    stringify!(centerDelay)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).prevDelay) as usize - ptr as usize },
                88usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ModulatedDelay),
                    "::",
                    stringify!(prevDelay)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).scalar) as usize - ptr as usize },
                92usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ModulatedDelay),
                    "::",
                    stringify!(scalar)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).oscFreq) as usize - ptr as usize },
                96usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ModulatedDelay),
                    "::",
                    stringify!(oscFreq)
                )
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).delayRange) as usize - ptr as usize },
                100usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ModulatedDelay),
                    "::",
                    stringify!(delayRange)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP14ModulatedDelay10initializeEyyff"]
            pub fn ModulatedDelay_initialize(
                this: *mut root::DSP::ModulatedDelay,
                minDelay: usize,
                maxDelay: usize,
                fb: f32,
                wet: f32,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP14ModulatedDelay13getNextSampleEf"]
            pub fn ModulatedDelay_getNextSample(
                this: *mut root::DSP::ModulatedDelay,
                sample: f32,
            ) -> f32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP14ModulatedDelay6resizeEy"]
            pub fn ModulatedDelay_resize(this: *mut root::DSP::ModulatedDelay, delayAmount: usize);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP14ModulatedDelay5flushEv"]
            pub fn ModulatedDelay_flush(this: *mut root::DSP::ModulatedDelay);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP14ModulatedDelay11setFeedbackEf"]
            pub fn ModulatedDelay_setFeedback(this: *mut root::DSP::ModulatedDelay, feedback: f32);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP14ModulatedDelay6setWetEf"]
            pub fn ModulatedDelay_setWet(this: *mut root::DSP::ModulatedDelay, wet_amount: f32);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP14ModulatedDelay8setDepthEf"]
            pub fn ModulatedDelay_setDepth(this: *mut root::DSP::ModulatedDelay, depth: f32);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP14ModulatedDelay12setFrequencyEff"]
            pub fn ModulatedDelay_setFrequency(
                this: *mut root::DSP::ModulatedDelay,
                frequency: f32,
                sampleRate: f32,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP14ModulatedDelay13setDelayRangeEii"]
            pub fn ModulatedDelay_setDelayRange(
                this: *mut root::DSP::ModulatedDelay,
                min: ::std::os::raw::c_int,
                max: ::std::os::raw::c_int,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP14ModulatedDelay13getWriteIndexEv"]
            pub fn ModulatedDelay_getWriteIndex(
                this: *mut root::DSP::ModulatedDelay,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP14ModulatedDelay12getReadIndexEv"]
            pub fn ModulatedDelay_getReadIndex(
                this: *mut root::DSP::ModulatedDelay,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP14ModulatedDelayC1Ev"]
            pub fn ModulatedDelay_ModulatedDelay(this: *mut root::DSP::ModulatedDelay);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP14ModulatedDelayC1Eyyff"]
            pub fn ModulatedDelay_ModulatedDelay1(
                this: *mut root::DSP::ModulatedDelay,
                minDelay: usize,
                maxDelay: usize,
                fb: f32,
                wet: f32,
            );
        }
        impl ModulatedDelay {
            #[inline]
            pub unsafe fn initialize(
                &mut self,
                minDelay: usize,
                maxDelay: usize,
                fb: f32,
                wet: f32,
            ) {
                ModulatedDelay_initialize(self, minDelay, maxDelay, fb, wet)
            }
            #[inline]
            pub unsafe fn getNextSample(&mut self, sample: f32) -> f32 {
                ModulatedDelay_getNextSample(self, sample)
            }
            #[inline]
            pub unsafe fn resize(&mut self, delayAmount: usize) {
                ModulatedDelay_resize(self, delayAmount)
            }
            #[inline]
            pub unsafe fn flush(&mut self) {
                ModulatedDelay_flush(self)
            }
            #[inline]
            pub unsafe fn setFeedback(&mut self, feedback: f32) {
                ModulatedDelay_setFeedback(self, feedback)
            }
            #[inline]
            pub unsafe fn setWet(&mut self, wet_amount: f32) {
                ModulatedDelay_setWet(self, wet_amount)
            }
            #[inline]
            pub unsafe fn setDepth(&mut self, depth: f32) {
                ModulatedDelay_setDepth(self, depth)
            }
            #[inline]
            pub unsafe fn setFrequency(&mut self, frequency: f32, sampleRate: f32) {
                ModulatedDelay_setFrequency(self, frequency, sampleRate)
            }
            #[inline]
            pub unsafe fn setDelayRange(
                &mut self,
                min: ::std::os::raw::c_int,
                max: ::std::os::raw::c_int,
            ) {
                ModulatedDelay_setDelayRange(self, min, max)
            }
            #[inline]
            pub unsafe fn getWriteIndex(&mut self) -> ::std::os::raw::c_int {
                ModulatedDelay_getWriteIndex(self)
            }
            #[inline]
            pub unsafe fn getReadIndex(&mut self) -> ::std::os::raw::c_int {
                ModulatedDelay_getReadIndex(self)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                ModulatedDelay_ModulatedDelay(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(minDelay: usize, maxDelay: usize, fb: f32, wet: f32) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                ModulatedDelay_ModulatedDelay1(
                    __bindgen_tmp.as_mut_ptr(),
                    minDelay,
                    maxDelay,
                    fb,
                    wet,
                );
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Flanger {
            pub modDly: root::DSP::ModulatedDelay,
        }
        #[test]
        fn bindgen_test_layout_Flanger() {
            const UNINIT: ::std::mem::MaybeUninit<Flanger> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<Flanger>(),
                104usize,
                concat!("Size of: ", stringify!(Flanger))
            );
            assert_eq!(
                ::std::mem::align_of::<Flanger>(),
                8usize,
                concat!("Alignment of ", stringify!(Flanger))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).modDly) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Flanger),
                    "::",
                    stringify!(modDly)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP7Flanger13getNextSampleEf"]
            pub fn Flanger_getNextSample(this: *mut root::DSP::Flanger, input: f32) -> f32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP7Flanger6setWetEf"]
            pub fn Flanger_setWet(this: *mut root::DSP::Flanger, wet: f32);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP7Flanger8setSpeedEff"]
            pub fn Flanger_setSpeed(this: *mut root::DSP::Flanger, frequency: f32, sampleRate: f32);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP7Flanger8setDepthEff"]
            pub fn Flanger_setDepth(
                this: *mut root::DSP::Flanger,
                milliseconds: f32,
                sampleRate: f32,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP7FlangerC1Ev"]
            pub fn Flanger_Flanger(this: *mut root::DSP::Flanger);
        }
        impl Flanger {
            #[inline]
            pub unsafe fn getNextSample(&mut self, input: f32) -> f32 {
                Flanger_getNextSample(self, input)
            }
            #[inline]
            pub unsafe fn setWet(&mut self, wet: f32) {
                Flanger_setWet(self, wet)
            }
            #[inline]
            pub unsafe fn setSpeed(&mut self, frequency: f32, sampleRate: f32) {
                Flanger_setSpeed(self, frequency, sampleRate)
            }
            #[inline]
            pub unsafe fn setDepth(&mut self, milliseconds: f32, sampleRate: f32) {
                Flanger_setDepth(self, milliseconds, sampleRate)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Flanger_Flanger(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Chorus {
            pub modDly: root::DSP::ModulatedDelay,
        }
        #[test]
        fn bindgen_test_layout_Chorus() {
            const UNINIT: ::std::mem::MaybeUninit<Chorus> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<Chorus>(),
                104usize,
                concat!("Size of: ", stringify!(Chorus))
            );
            assert_eq!(
                ::std::mem::align_of::<Chorus>(),
                8usize,
                concat!("Alignment of ", stringify!(Chorus))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).modDly) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Chorus),
                    "::",
                    stringify!(modDly)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP6Chorus13getNextSampleEf"]
            pub fn Chorus_getNextSample(this: *mut root::DSP::Chorus, input: f32) -> f32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP6Chorus6setWetEf"]
            pub fn Chorus_setWet(this: *mut root::DSP::Chorus, wet: f32);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP6Chorus8setSpeedEff"]
            pub fn Chorus_setSpeed(this: *mut root::DSP::Chorus, frequency: f32, sampleRate: f32);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP6Chorus8setDepthEif"]
            pub fn Chorus_setDepth(
                this: *mut root::DSP::Chorus,
                milliseconds: ::std::os::raw::c_int,
                sampleRate: f32,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP6ChorusC1Ev"]
            pub fn Chorus_Chorus(this: *mut root::DSP::Chorus);
        }
        impl Chorus {
            #[inline]
            pub unsafe fn getNextSample(&mut self, input: f32) -> f32 {
                Chorus_getNextSample(self, input)
            }
            #[inline]
            pub unsafe fn setWet(&mut self, wet: f32) {
                Chorus_setWet(self, wet)
            }
            #[inline]
            pub unsafe fn setSpeed(&mut self, frequency: f32, sampleRate: f32) {
                Chorus_setSpeed(self, frequency, sampleRate)
            }
            #[inline]
            pub unsafe fn setDepth(
                &mut self,
                milliseconds: ::std::os::raw::c_int,
                sampleRate: f32,
            ) {
                Chorus_setDepth(self, milliseconds, sampleRate)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Chorus_Chorus(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Vibrato {
            pub modDly: root::DSP::ModulatedDelay,
        }
        #[test]
        fn bindgen_test_layout_Vibrato() {
            const UNINIT: ::std::mem::MaybeUninit<Vibrato> = ::std::mem::MaybeUninit::uninit();
            let ptr = UNINIT.as_ptr();
            assert_eq!(
                ::std::mem::size_of::<Vibrato>(),
                104usize,
                concat!("Size of: ", stringify!(Vibrato))
            );
            assert_eq!(
                ::std::mem::align_of::<Vibrato>(),
                8usize,
                concat!("Alignment of ", stringify!(Vibrato))
            );
            assert_eq!(
                unsafe { ::std::ptr::addr_of!((*ptr).modDly) as usize - ptr as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Vibrato),
                    "::",
                    stringify!(modDly)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP7Vibrato13getNextSampleEf"]
            pub fn Vibrato_getNextSample(this: *mut root::DSP::Vibrato, input: f32) -> f32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP7Vibrato6setWetEf"]
            pub fn Vibrato_setWet(this: *mut root::DSP::Vibrato, wet: f32);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP7Vibrato8setSpeedEff"]
            pub fn Vibrato_setSpeed(this: *mut root::DSP::Vibrato, frequency: f32, sampleRate: f32);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP7Vibrato8setDepthEif"]
            pub fn Vibrato_setDepth(
                this: *mut root::DSP::Vibrato,
                milliseconds: ::std::os::raw::c_int,
                sampleRate: f32,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN3DSP7VibratoC1Ev"]
            pub fn Vibrato_Vibrato(this: *mut root::DSP::Vibrato);
        }
        impl Vibrato {
            #[inline]
            pub unsafe fn getNextSample(&mut self, input: f32) -> f32 {
                Vibrato_getNextSample(self, input)
            }
            #[inline]
            pub unsafe fn setWet(&mut self, wet: f32) {
                Vibrato_setWet(self, wet)
            }
            #[inline]
            pub unsafe fn setSpeed(&mut self, frequency: f32, sampleRate: f32) {
                Vibrato_setSpeed(self, frequency, sampleRate)
            }
            #[inline]
            pub unsafe fn setDepth(
                &mut self,
                milliseconds: ::std::os::raw::c_int,
                sampleRate: f32,
            ) {
                Vibrato_setDepth(self, milliseconds, sampleRate)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Vibrato_Vibrato(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
        }
    }
    extern "C" {
        pub fn __pctype_func() -> *mut ::std::os::raw::c_ushort;
    }
    extern "C" {
        pub static mut __imp__wctype: *mut *mut ::std::os::raw::c_ushort;
    }
    extern "C" {
        pub static mut __imp__pwctype: *mut *mut ::std::os::raw::c_ushort;
    }
    extern "C" {
        pub static __newclmap: [::std::os::raw::c_uchar; 0usize];
    }
    extern "C" {
        pub static __newcumap: [::std::os::raw::c_uchar; 0usize];
    }
    extern "C" {
        pub static mut __ptlocinfo: root::pthreadlocinfo;
    }
    extern "C" {
        pub static mut __ptmbcinfo: root::pthreadmbcinfo;
    }
    extern "C" {
        pub static mut __globallocalestatus: ::std::os::raw::c_int;
    }
    extern "C" {
        pub static mut __locale_changed: ::std::os::raw::c_int;
    }
    extern "C" {
        pub static mut __initiallocinfo: root::threadlocaleinfostruct;
    }
    extern "C" {
        pub static mut __initiallocalestructinfo: root::_locale_tstruct;
    }
    extern "C" {
        pub fn __updatetlocinfo() -> root::pthreadlocinfo;
    }
    extern "C" {
        pub fn __updatetmbcinfo() -> root::pthreadmbcinfo;
    }
    extern "C" {
        pub fn _isctype(
            _C: ::std::os::raw::c_int,
            _Type: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _isctype_l(
            _C: ::std::os::raw::c_int,
            _Type: ::std::os::raw::c_int,
            _Locale: root::_locale_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn isalpha(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _isalpha_l(
            _C: ::std::os::raw::c_int,
            _Locale: root::_locale_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn isupper(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _isupper_l(
            _C: ::std::os::raw::c_int,
            _Locale: root::_locale_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn islower(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _islower_l(
            _C: ::std::os::raw::c_int,
            _Locale: root::_locale_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn isdigit(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _isdigit_l(
            _C: ::std::os::raw::c_int,
            _Locale: root::_locale_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn isxdigit(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _isxdigit_l(
            _C: ::std::os::raw::c_int,
            _Locale: root::_locale_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn isspace(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _isspace_l(
            _C: ::std::os::raw::c_int,
            _Locale: root::_locale_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn ispunct(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _ispunct_l(
            _C: ::std::os::raw::c_int,
            _Locale: root::_locale_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn isalnum(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _isalnum_l(
            _C: ::std::os::raw::c_int,
            _Locale: root::_locale_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn isprint(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _isprint_l(
            _C: ::std::os::raw::c_int,
            _Locale: root::_locale_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn isgraph(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _isgraph_l(
            _C: ::std::os::raw::c_int,
            _Locale: root::_locale_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn iscntrl(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _iscntrl_l(
            _C: ::std::os::raw::c_int,
            _Locale: root::_locale_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn toupper(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn tolower(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _tolower(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _tolower_l(
            _C: ::std::os::raw::c_int,
            _Locale: root::_locale_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _toupper(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _toupper_l(
            _C: ::std::os::raw::c_int,
            _Locale: root::_locale_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn __isascii(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn __toascii(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn __iscsymf(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn __iscsym(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn isblank(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn iswalpha(_C: root::wint_t) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _iswalpha_l(_C: root::wint_t, _Locale: root::_locale_t) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn iswupper(_C: root::wint_t) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _iswupper_l(_C: root::wint_t, _Locale: root::_locale_t) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn iswlower(_C: root::wint_t) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _iswlower_l(_C: root::wint_t, _Locale: root::_locale_t) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn iswdigit(_C: root::wint_t) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _iswdigit_l(_C: root::wint_t, _Locale: root::_locale_t) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn iswxdigit(_C: root::wint_t) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _iswxdigit_l(_C: root::wint_t, _Locale: root::_locale_t) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn iswspace(_C: root::wint_t) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _iswspace_l(_C: root::wint_t, _Locale: root::_locale_t) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn iswpunct(_C: root::wint_t) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _iswpunct_l(_C: root::wint_t, _Locale: root::_locale_t) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn iswalnum(_C: root::wint_t) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _iswalnum_l(_C: root::wint_t, _Locale: root::_locale_t) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn iswprint(_C: root::wint_t) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _iswprint_l(_C: root::wint_t, _Locale: root::_locale_t) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn iswgraph(_C: root::wint_t) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _iswgraph_l(_C: root::wint_t, _Locale: root::_locale_t) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn iswcntrl(_C: root::wint_t) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _iswcntrl_l(_C: root::wint_t, _Locale: root::_locale_t) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn iswascii(_C: root::wint_t) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn isleadbyte(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _isleadbyte_l(
            _C: ::std::os::raw::c_int,
            _Locale: root::_locale_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn towupper(_C: root::wint_t) -> root::wint_t;
    }
    extern "C" {
        pub fn _towupper_l(_C: root::wint_t, _Locale: root::_locale_t) -> root::wint_t;
    }
    extern "C" {
        pub fn towlower(_C: root::wint_t) -> root::wint_t;
    }
    extern "C" {
        pub fn _towlower_l(_C: root::wint_t, _Locale: root::_locale_t) -> root::wint_t;
    }
    extern "C" {
        pub fn iswctype(_C: root::wint_t, _Type: root::wctype_t) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _iswctype_l(
            _C: root::wint_t,
            _Type: root::wctype_t,
            _Locale: root::_locale_t,
        ) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn __iswcsymf(_C: root::wint_t) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _iswcsymf_l(_C: root::wint_t, _Locale: root::_locale_t) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn __iswcsym(_C: root::wint_t) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn _iswcsym_l(_C: root::wint_t, _Locale: root::_locale_t) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn is_wctype(_C: root::wint_t, _Type: root::wctype_t) -> ::std::os::raw::c_int;
    }
    extern "C" {
        pub fn iswblank(_C: root::wint_t) -> ::std::os::raw::c_int;
    }
    extern "C" {
        #[link_name = "\u{1}_Z14floatToDecibelf"]
        pub fn floatToDecibel(arg1: f32) -> f32;
    }
    extern "C" {
        #[link_name = "\u{1}_Z14decibelToFloatf"]
        pub fn decibelToFloat(arg1: f32) -> f32;
    }
    extern "C" {
        #[link_name = "\u{1}_Z11msToSamplesff"]
        pub fn msToSamples(arg1: f32, arg2: f32) -> f32;
    }
    extern "C" {
        #[link_name = "\u{1}_Z11samplesToMsff"]
        pub fn samplesToMs(arg1: f32, arg2: f32) -> f32;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_1 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_2 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_3 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_4 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_5 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_6 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_7 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_8 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_9 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_10 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_11 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_12 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_13 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_14 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_15 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_16 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_17 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_18 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_19 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_20 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_21 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_22 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_23 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_24 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_25 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_26 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_27 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_28 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_29 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_30 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_31 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_32 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_33 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_34 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_35 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_36 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_37 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_38 {
        pub _address: u8,
    }
    pub type size_type = usize;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_39 {
        pub _address: u8,
    }
    pub type __builtin_va_list = *mut ::std::os::raw::c_char;
}
